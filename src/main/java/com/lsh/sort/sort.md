# 常见排序算法总结

| 排序算法     | 时间复杂度（平均/最坏/最好）                      | 空间复杂度          | 稳定性 | 备注              |
| -------- | ------------------------------------ | -------------- | --- | --------------- |
| **冒泡排序** | O(n²) / O(n²) / O(n)                 | O(1)           | 稳定  | 简单但效率低，适合小规模数据  |
| **选择排序** | O(n²) / O(n²) / O(n²)                | O(1)           | 不稳定 | 每次选择最小/最大元素交换   |
| **插入排序** | O(n²) / O(n²) / O(n)                 | O(1)           | 稳定  | 对部分有序数组表现很好     |
| **归并排序** | O(n log n) / O(n log n) / O(n log n) | O(n)           | 稳定  | 需要额外空间，分治法      |
| **快速排序** | O(n log n) / O(n²) / O(n log n)      | O(log n)\~O(n) | 不稳定 | 通常最快，递归空间视实现而定  |
| **堆排序**  | O(n log n) / O(n log n) / O(n log n) | O(1)           | 不稳定 | 原地排序，空间小，但不稳定   |
| **计数排序** | O(n + k) / O(n + k) / O(n + k)       | O(k)           | 稳定  | 适用于整数且范围不大的情况   |
| **桶排序**  | O(n + k) / O(n²) / O(n)              | O(n + k)       | 稳定  | 适合均匀分布数据        |
| **基数排序** | O(d\*(n + k))                        | O(n + k)       | 稳定  | 适合整数或字符串等多关键字排序 |


---

时间复杂度：
 - 大O表示法:忽略常数项和低阶项，只关注最高阶的项（如 3n^2 +2n +1 简化为O(n^2) ）

空间复杂度：
 - 空间复杂度：是对一个算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))

稳定性：如果两个元素的值相等，排序后它们的相对顺序保持不变，那么这个排序算法是稳定的。

```
原数组：[(A, 3), (B, 2), (C, 3)]
         ↑           ↑
排序后：[(B, 2), (A, 3), (C, 3)] ✅ 稳定
排序后：[(B, 2), (C, 3), (A, 3)] ❌ 不稳定（3 相等，但 A、C 顺序变了）

```

---

常见模式总结：
|代码结构|时间复杂度|示例算法|
| :---: | :---: | :---: |
|单层循环|O(n)|线性搜索|
|双层嵌套循环|O(n^2)|冒泡排序、选择排序|
|分治（Divide & Conquer）|O(n*logn)| 归并排序、快速排序|
|递归减半|O(logn)、O(n!)|二分查找 |
|全排列/组合|O(n!)|旅行商问题（暴力解） |
---

## BubbleSort 冒泡排序

**算法思想：通过相邻邻元素的比较和交换，将较大的元素逐渐“冒泡”到数组的末尾。**

**算法步骤：**
 1. 从数组第一个元素开始，依次比较相邻的两个元素。
 2. 如果前一个元素大于后一个元素，则交换它们的位置。
 3. 每一轮结束后，最大的元素会“冒泡”到数组末尾。
 4. 重复上述步骤，直到整个数组都有序。

**示例：**
排序数组：[5, 3, 8, 6, 2]

- 第一轮：

  [5, 3] → 交换 → [3, 5, 8, 6, 2]
  
  [5, 8] → 不交换
  
  [8, 6] → 交换 → [3, 5, 6, 8, 2]
    
    [8, 2] → 交换 → [3, 5, 6, 2, 8]（最大元素 8 已到位）

- 第二轮：
    重复上述过程，最终得到 [2, 3, 5, 6, 8]。

**特点：**
- 时间复杂度：O(n^2)
- 空间复杂度：O(1)（原地排序）。
- 稳定性：✅ 稳定（相等元素不交换）。



**代码实现：**
```java
//外层循环控制排序轮数，内层循环控制每一轮的比较次数。
//每一轮结束后，最大的元素会“冒泡”到数组末尾，所以内层循环的次数会逐渐减少。
public static void bubbleSort(int[] arr) {
    for(int i = 0; i < arr.length - 1; i++){
        for(int j = 0; j < arr.length - i - 1; j++){
            if(arr[j] > arr[j+1]){
                int temp = arr[j+1];
                arr[j+1] = arr[j];
                arr[j] = temp;
            }   
        }    
    }
}
```

**注意：**
- 外层循环边界：`i < arr.length - 1` 是因为最后一个元素已经是最大的了，不需要再比较了。
- 内层循环边界：`j < arr.length - i - 1` 是因为每一轮结束后，最大的元素已经“冒泡”到数组末尾，不需要再比较了。



冒泡算法时间复杂度最好情况：数组已经是有序的，（即内层循环没有发生交换即代表数组有序）只需要进行 n-1 次比较，时间复杂度为 O(n)。
```java
boolean swapped = false;
for (int i = 0; i < n - 1; i++) {
    for (int j = 0; j < n - 1 - i; j++) {
        if (arr[j] > arr[j + 1]) {
            swap(arr, j, j + 1);
            swapped = true;
        }
    }
    if (!swapped) break; // 如果没有发生交换，说明已经有序，可以提前结束
}

```


## SelectionSort 选择排序

**算法思想：每次从未排序的部分中选择最小（或最大）的元素，将其放到已排序部分的末尾。**

**算法步骤：**
 1. 将数组分为 已排序区间（左）和 未排序区间（右）。
 2. 遍历未排序部分的所有元素，找到最小（或最大）的元素。
 3. 将最小（或最大）的元素与未排序部分的第一个元素交换位置。
 4. 已排序部分的长度增加 1，未排序部分的长度减少 1。
 5. 重复上述步骤，直到整个数组都有序。

**示例：**
排序数组：[5, 3, 8, 6, 2]
- 第一轮：
    未排序区间 [5, 3, 8, 6, 2]，最小元素是 2，与 5 交换 → [2, 3, 8, 6, 5]
- 第二轮：
    未排序区间 [3, 8, 6, 5]，最小元素是 3（已在正确位置）。
- 第三轮：
    未排序区间 [8, 6, 5]，最小元素是 5，与 8 交换 → [2, 3, 5, 6, 8]。

**特点：**
- 时间复杂度：O(n^2)
- 空间复杂度：O(1)（原地排序）。
- 稳定性：❌ 不稳定（相等元素可能会交换位置）。

**代码实现：**
```java
void selectionSort(int[] arr) {
    for (int i = 0; i < arr.length - 1; i++) {
        int minIndex = i;
        for (int j = i + 1; j < arr.length; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        int temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
}
```
**注意：**
- 外层循环边界：`i < arr.length - 1` 是因为最后一个元素已经是最大的了，不需要再比较了。
- 内层循环边界：`j < arr.length` 是因为需要遍历未排序部分的所有元素。
- 内层循环中，`minIndex` 记录当前未排序部分的最小元素的索引。

不稳定：相等元素可能会交换位置。
例如：`[(3, A), (3, C), (2, B)]`
第一轮最小值是 (2, B)，和 (3, A) 交换，得到：`[(2, B), (3, C), (3, A)]`。
现在 (3, A) 在 (3, C) 后面，原顺序被打乱，不稳定 ❌

## InsertionSort 插入排序
**算法思想：将数组分为已排序部分和未排序部分，每次将未排序部分的第一个元素插入到已排序部分的正确位置。**

**算法步骤：**
 1. 将数组分为 已排序区间（左）和 未排序区间（右），初始时，已排序区间只有第一个元素。
 2. 取未排序区间的第一个元素，在已排序区间中 从后向前扫描，找到合适位置插入。
 3. 重复上述过程，直到所有元素有序。

**示例：**
排序数组：[5, 3, 8, 6, 2]
- 第一轮：
    已排序 [5]，未排序 [3, 8, 6, 2]。
    3 插入到 5 前 → [3, 5, 8, 6, 2]
- 第二轮：
    8 比 5 大，无需移动 → [3, 5, 8, 6, 2]
- 第三轮：
    6 插入到 8 前 → [3, 5, 6, 8, 2]
- 第四轮：
    2 依次插入到 3 前 → [2, 3, 5, 6, 8]。

**特点：**
- 时间复杂度：O(n^2)
- 空间复杂度：O(1)（原地排序）。
- 稳定性：✅ 稳定（相等元素不交换）。   

**代码实现：**
```java
void insertionSort(int[] arr) {
    for (int i = 1; i < arr.length; i++) {
        int temp = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > temp) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = temp;
    }
}
```
**注意：**
- 外层循环边界：`i < arr.length` 
- 内层while循环边界：`j >= 0` 是因为需要遍历已排序部分的所有元素。
- 内层循环中，`temp` 记录当前未排序部分的第一个元素，`j` 记录已排序部分的最后一个元素的索引。
- 内层循环中，`arr[j + 1] = arr[j]` 将已排序部分的元素后移一位，为当前未排序部分的第一个元素腾出位置。
- 内层循环结束后，`arr[j + 1] = temp` 将当前未排序部分的第一个元素插入到正确位置。

## MergeSort 归并排序
归并排序（Merge Sort） 是一种 分治法（Divide and Conquer） 的典型应用。

**算法思想：** 将数组分成两半，分别排序，再合并为一个有序数组。

**算法步骤：** 归并排序采用 **递归** 分解数组，然后逐步合并有序子数组
  1. 分解：将数组从中间一分为二，递归地对子数组排序。(当子数组大小为 1 时，认为它是有序的。)
  2. 合并：将两个有序子数组合并成一个有序数组。


**示例：**
输入数组：`[12, 11, 13, 5, 6, 7]`
执行过程：
  1. 分解为 `[12, 11, 13]` 和 `[5, 6, 7]`。
  2. 进一步分解到单个元素后，逐步合并：
        - 合并 `[12]` 和 `[11]` → `[11, 12]`
        - 合并 `[11, 12]` 和 `[13]` → `[11, 12, 13]`
        - 合并 `[5]` 和 `[6]` → `[5, 6]`
        - 合并 `[5, 6] 和 [7]` → `[5, 6, 7]`
  3. 最终合并 `[11, 12, 13]` 和 `[5, 6, 7]` → `[5, 6, 7, 11, 12, 13]`。

**性能分析：**
- 时间复杂度：O(nlogn)
- 空间复杂度：O(n)（需要额外的空间来存储合并后的数组）。
- 稳定性：✅ 稳定（相等元素不交换）。



**代码实现：**

```java
    public static void mergeSort(int[] array) {
        if (array == null || array.length < 2) return;
        int[] temp = new int[array.length]; // 只创建一次临时数组, 避免递归中频繁创建
        mergeSort(array, 0, array.length - 1, temp);
    }

    private static void mergeSort(int[] array, int left, int right, int[] temp) {
        // 递归终止条件：用于判断当前数组是否还需要继续分割。
        // 当 left == right 时，表示数组区间只有一个元素，这时是有序的，不需要再分。
        if (left >= right) return;

        //防止溢出的中点计算方法
        int mid = left + (right - left) / 2;

        // 分成两半递归排序
        mergeSort(array, left, mid, temp);// 排序左半部分
        mergeSort(array, mid + 1, right, temp);// 排序右半部分

        // 合并两个有序子数组
        merge(array, left, mid, right, temp);
    }

    private static void merge(int[] array, int left, int mid, int right, int[] temp) {
        int i = left;     // 左子数组指针
        int j = mid + 1;  // 右子数组指针
        int k = left;     // temp 数组的起始索引（从 left 开始）

        while (i <= mid && j <= right) {
            if (array[i] <= array[j]) {
                temp[k++] = array[i++];
            } else {
                temp[k++] = array[j++];
            }
        }

        while (i <= mid){
            temp[k++] = array[i++];
        }
        while (j <= right){
            temp[k++] = array[j++];
        }

        // 将排序结果拷贝回原数组
        for (int m = left; m <= right; m++) {
            array[m] = temp[m];
        }
    }

```


## QuickSort 快速排序

**算法思想：** 快速排序是一种 分治算法，通过选择一个 基准（pivot） 将数组分为两部分，左边小于基准，右边大于基准，然后递归排序左右部分。

**算法步骤：**
  1. 选择基准（pivot）：从数组中选择一个元素作为基准，通常选择第一个元素(或最后一个元素、中间元素)。
  2. 分区（Partition）：将数组分为两部分，小于基准的放在左边，大于基准的放在右边。
  3. 递归排序：对左右两部分分别递归地进行快速排序。


**性能分析：**
- 时间复杂度：O(nlogn)
- 空间复杂度：O(logn)（递归调用栈的深度）。
- 稳定性：❌ 不稳定（相等元素可能会交换位置）。
**代码实现：**
```java

void quickSort(int[] arr, int left, int right){
      if(left < right){
        int pivotIndex = partition(arr, left, right);
        quickSort(arr, left, pivotIndex - 1);
        quickSort(arr, pivotIndex + 1, right);
      }
}

int partition(int[] arr, int left, int right){
    int pivot = arr[right];
    int i = left - 1;
    for(int j = left; j< right; j++){
        if(arr[j] < pivot){
            i++;
            swap(arr, i, j);
        } 
    }
    swap(arr, i+1, right);
    return i+1;
}

void swap(int[] arr, int i, int j){
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}


```

**注意：**
- 递归终止条件：当 left >= right 时，表示数组区间只有一个元素或为空，不需要再排序。
- 分区过程：使用双指针 i 和 j 分别从左到右扫描数组，将小于基准的元素放到左边，大于基准的元素放到右边。
- 递归调用：对左右两部分分别递归地进行快速排序。


## HeapSort 堆排序

`Heap Sort` 堆排序 是一种基于二叉堆（Binary Heap）数据结构的比较排序算法。

首先要了解二叉堆的数据结构，二叉堆是一种 完全二叉树（Complete Binary Tree）结构，并且满足以下两个条件之一：
  - **大顶堆（Max Heap）：** 每个节点的值都大于或等于其左右子节点的值，最大值位于根节点。
  - **小顶堆（Min Heap）：** 每个节点的值都小于或等于其左右子节点的值，最小值位于根节点。

除了最后一层外，每一层都是满的；最后一层从左往右依次填充；

--- 

- 叶子节点：没有任何子节点的节点。叶子节点是二叉树的最底层节点，没有左子节点也没有右子节点。
- 非叶子节点：至少有一个子节点的节点。非叶子节点在树中处于中间位置，有左孩子或右孩子（或两个孩子）。
- 根节点：没有父节点的节点。根节点是树的顶部节点，没有任何父节点。


| 节点类型  | 索引范围           | 需不需要堆化 |
| ----- | -------------- | ------ |
| 叶子节点  | `[n/2, n-1]`   | 不需要    |
| 非叶子节点 | `[0, n/2 - 1]` | 需要     |


**推导过程：**

因为如果节点 i 满足 `2*i + 1 >= n`，(此时n已经超出数组长度)说明它没有左子节点（右子节点也必然没有），所以它是叶子节点。`2*i + 1 >= n` 等价于 `i >= n/2`。所以叶子节点的索引范围就是 `[n/2, n-1]`。

非叶子节点需要满足至少有一个左子节点，非叶子节点的范围是`[0, n/2 - 1]`，假设最大的叶子节点（`n-1`）是非叶子节点的左子节点(`2*i+1`)
即： `2*i + 1 = n - 1` **=>** `i = n/2 - 1`
所以非叶子节点的索引范围就是 `[0, n/2 - 1]`。


---



使用数组来表示二叉堆：
假设当前节点索引（从索引 0 开始）是 `i`：
| 节点位置 | 公式            | 举例（i = 1）       |
| ---- | ------------- | --------------- |
| 父节点  | `(i - 1) / 2` | `(1 - 1)/2 = 0` |
| 左子节点 | `2 * i + 1`   | `2 * 1 + 1 = 3` |
| 右子节点 | `2 * i + 2`   | `2 * 1 + 2 = 4` |

假设有一个数组：`int[] heap = {50, 30, 40, 10, 20, 35, 25};`
对应的完全二叉树结构如下：
```
           50
         /    \
       30      40
      /  \    /  \
    10   20  35  25

```
---

| 索引 | 值  | 左子节点  | 右子节点  | 父节点   |
| -- | -- | ----- | ----- | ----- |
| 0  | 50 | 1(30) | 2(40) | -     |
| 1  | 30 | 3(10) | 4(20) | 0(50) |
| 2  | 40 | 5(35) | 6(38) | 0(50) |
| 3  | 10 | -     | -     | 1(30) |
| 4  | 20 | -     | -     | 1(30) |
| 5  | 35 | -     | -     | 2(40) |
| 6  | 38 | -     | -     | 2(40) |

---

**算法思想：**
  1. **建堆（Heapify）：** 将待排序数组构建成一个最大堆（或最小堆）。
  2. **排序：** 反复将堆顶最大元素与堆末尾元素交换，并重新调整堆

**性能分析：**
- 时间复杂度：O(nlogn)
- 空间复杂度：O(1)（原地排序）。
- 稳定性：❌ 不稳定（相等元素可能会交换位置）。

**示例：**
初始数组：[4, 10, 3, 5, 1]

1. 建堆后：[10, 5, 3, 4, 1]
2. 第一次排序后：[1, 5, 3, 4, 10]（10 固定）
3. 第二次排序后：[4, 1, 3, 5, 10]
4. 第三次排序后：[3, 1, 4, 5, 10]
5. 第四次排序后：[1, 3, 4, 5, 10]

**代码实现：**
```java

void heapSort(int[] arr){
    if(arr == null || arr.length < 2) return;

    int n = arr.length;
    //1. 构建最大堆（从最后一个非叶子节点（n/2 - 1）开始往上堆化；）
    for(int i = n / 2 - 1; i >= 0; i--){
        heapify(arr, n, i);
    }

    //2. 排序:此时数组已经是一个大顶堆，堆顶节点为数组最大值，将对顶节点与末尾元素交换，然后重新调整堆
    for(int i = n - 1; i >= 0; i--){
        swap(arr, 0, i);// 将堆顶元素与末尾元素交换
        heapify(arr, i, 0);// 重新对剩下的元素堆化（堆大小减1）
    }
}

/**
 * 调整大顶堆：对于任意节点，array[i] ≥ array[2i+1] 和 array[i] ≥ array[2i+2]
 */
void heapify(int[] arr, int n, int i){
    int largest = i;//当前根节点索引
    int left = 2 * i + 1;//左子节点
    int right = 2 * i + 2;//右子节点

    //找出最大值的索引（2 * i + 1可能越界，超出数组长度，）
    if(left < n && arr[left] > arr[largest]){
        // 左子节点比根大
        largest = left;
    }

    if(right < n && arr[right] > arr[largest]){
        // 右子节点比当前最大还大
        largest = right;
    }
    //最终 largest 就是根、左、右三者中值最大的那个索引。
    //如果最大值不是根节点，交换根节点和最大值，并递归调整堆
    if(largest != i){
        swap(arr, i, largest);
        //发生了交换，才进行递归操作
        heapify(arr, n, largest);
    }
}


```

注意：
  - 建堆过程：从最后一个非叶子节点`（n/2 -1）`开始往上堆化。
  - 建堆过程：只遍历非叶子节点。因为叶子节点没有子节点，天生满足堆性质，不需要堆化。
  - 排序过程：每次将堆顶元素(`index = 0`)与末尾元素(`n-1`)交换，然后重新调整堆（`堆大小减1`）。
  - 堆性质：**只要求父节点大于等于子节点即可，不需要左右子节点的大小关系**。
  - 递归调整堆：如果发生了交换，才进行递归操作，重新调整堆结构。
