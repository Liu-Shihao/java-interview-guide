
## Java基础方面

### 抽象类与接口的区别
这个问题有问到过一两次，属于是Java最基础的概念内容，平常只做业务开发，谁记得这东西？但是面试会问到，你如果回答不上来还会说你Java基础不好...

- 抽象类和接口都不能实例化
- 抽象类可以有构造方法；接口不能有构造方法。
- 抽象类可以有具体方法和抽象方法；接口Java 8之前只能有抽象方法（没有方法体），Java 8之后引入了默认方法和静态方法。
- 类是单继承，一个类只能继承一个抽象类；一个类可以实现多个接口。


### ==和equals()的区别

`==`对于基本数据类型比较值是否相等，对于引用数据类型比较对象内存地址是否相同。<br>
`equals方法`没有重写的时候作用和`==`是一样的，比较的是对象的内存地址。
重写后的`equals方法`比较对象的值是否相同。例如String类重写了equals方法。

### equals()和hashcode()的关系
重写 `equals()` 必须重写 `hashCode()`。<br>
根据Java规范，相等的对象必须有相同的hashCode。如果不重写，可能导致HashMap等集合无法正确工作。

equals方法比较相同的对象，hashCode一定相同。<br>
但是hashCode相同的两个对象不一定是相同的对象，equals方法不一定相等。

### HashMap底层原理 
这个问题算是老生常谈的问题了，几乎每次跳槽面试都会问到。

HashMap底层采用**数组+链表+红黑树**（JDK1.8+）的结构存储数据。 <br>
核心存储使用一个 **Node[ ]** 哈希桶数组 存储数据。 <br>
数组的每一个位置称为一个 **桶 bucket**。 <br>
每一个Node存储 hash值、key、value和next指针。<br>

HashMap使用数组存储数据，数组中的每一个元素都是一个链表头，当发生哈希冲突时，会在冲突位置创建链表插入新元素。当链表长度大于8且数组容量超过64时，链表会转化为红黑树。提高链表的查询效率，时间复杂度从O(n)提升到O(logn)。

数组的初始容量为16 （1<<4） <br>
数组扩容的负载因子（loadFactor）是 0.75 <br>
数组扩容阈值是 capacity * loadFactor：16 * 0.75 = 12 <br>
链表树化阈值是8，链表长度达到8时转为红黑树<br>
树节点数小于6时转回链表

##### HashMap如何解决哈希冲突？
1. 优化hash算法：将hash无符号右移16位，让高位参与运算，与低位异或操作，减少哈希冲突（`(h = key.hashCode()) ^ (h >>> 16)`）。
2. 链地址法（拉链法）：每个数组元素（桶）都是一个链表头节点。当不同key计算出的索引位置相同时，会在发生哈希冲突的位置形成链表存储新元素。JDK1.7使用头插法，JDK1.8优化为尾插法，解决并发扩容时循环链表问题。


##### 链表树化长度为什么是8？解树化阈值为什么是6？
链表树化长度为8是根据泊松分布，hash冲突达到8的概率极低。<br>
解树化阈值为6是为了避免频繁的树化和解树化（设置差值作为缓冲）。


##### 在多线程场景中使用HashMap会有什么问题？
HashMap不是线程安全的。
所以在多线程场景下使用HashMap的时候会有安全问题：<br>
JDK1.7并发resize扩容会形成环形链表，导致死循环，头插法引起。<br>
JDK1.8并发put会导致数据覆盖。



### ConcurrentHashMap保证线程安全的原理

这个问题也是比较经典的问题了

ConcurrentHashMap是线程安全的HashMap实现。<br>
在JDK1.7中使用分段锁 Segments 机制实现线程安全。默认16个Segment，每个Segment独立加锁。先定位Segment，再定位桶。写操作时只锁定操作的Segment，其他Segment可继续访问。读操作无锁，使用volatile保证可见性。


JDK1.8使用 CAS + Volatile + Synchronized实现线程安全。<br>
优化了锁粒度：从Segment级别细化到桶级别（头节点）
锁升级：无锁时首先用CAS操作尝试写入，如果CAS操作失败，再使用synchronized锁定单个桶。
读操作无锁，使用Volatile保证线程间可见性，不需要加锁。

## 多线程与并发

多线程与并发问题也是面试会考察的内容。

### 并发与并行的区别

并发：多个任务在同一时间段内交替执行，需要争夺CPU资源。<br>
并行：多个任务在同一时刻同时执行，通常需要多核CPU支持

### start()方法与run()方法的区别
`start()`方法会启动一个新线程，并在新线程中执行`run()`方法；<br>
直接调用`run()`方法不会创建新线程，而是在当前线程中同步执行

`start()`方法只能调用一次，否则会抛出`IllegalThreadStateException`异常。
### 线程池的核心参数 
1. corePoolSize 核心线程数，线程池中保持的线程数，即使这些线程处于空闲状态，也不会被销毁。
2. maximumPoolSize 最大线程数，线程池中允许的最大线程数，当核心线程数已满且任务队列已满时，线程池会创建新的线程，直到达到最大线程数。
3. keepAliveTime 线程空闲时间，当线程数超过核心线程数时，多余的空闲线程在终止前等待新任务的最长时间。
4. unit 时间单位，	keepAliveTime的时间单位
5. workQueue 任务队列，用于存放待执行任务的队列。
6. threadFactory 线程工厂，用于创建新线程的工厂
7. handler 拒绝策略，当线程池和任务队列都满时，新任务的处理策略，如直接拒绝、丢弃旧任务、丢弃新任务等

### 线程池的参数如何配置？如何优化？
对于CPU密集型，一般配置核心线程数为cpu核数，最大线程数设置为cpu核数的两倍。<br>
`int cpuCores = Runtime.getRuntime().availableProcessors();` <br>
对于IO密集型任务，核心线程数可以设置为cpu核数的2倍到5倍，最大线程数一般为核心线程数的2倍。<br>
队列容量可以根据压测结果设定。如果队列使用率持续>80%，可以扩容调整。如果队列持续空闲（使用率<30%），可以缩容。



### 线程池的拒绝策略
1. AbortPolicy：直接抛出RejectedExecutionException异常，阻止系统正常工作
2. CallerRunsPolicy：由调用线程处理该任务
3. DiscardPolicy：丢弃任务，不抛出异常
4. DiscardOldestPolicy：丢弃队列中等待最久的任务，然后把当前任务加入队列中
5. 实现RejectedExecutionHandler 接口，自定义拒绝策略。
### 线程池的执行过程
1. 线程池创建时，会创建corePoolSize个核心线程
2. 当有新任务提交时，会判断当前线程数是否小于等于核心线程数，如果是，则创建新线程执行任务
3. 如果当前线程数大于核心线程数，则将任务放入任务队列中
4. 如果任务队列已满，则创建新线程执行任务，直到线程数达到最大线程数
5. 如果线程数达到最大线程数，且任务队列已满，则根据拒绝策略处理新任务
6. 当线程空闲时间超过空闲时间时，线程会被销毁

### Volatile的作用
volatile两个核心的作用：
1. 保证变量线程间的可见性。当一个变量被声明为 volatile 时，对该变量的修改会立即刷新到主内存中，而对该变量的读取也会从主内存中获取最新的值。
2. 禁止指令重排序。JVM 和 CPU 会对指令进行优化重排，volatile 关键字通过插入内存屏障(Memory Barrier)实现了禁止指令重排序，保证了代码的执行顺序。

但是Volatile不保证原子性。


### Synchronized与Lock的区别
`synchronized`是Java中实现线程安全的一种锁机制。synchronized可以修饰方法和代码块。确保同一时间只有一个线程可以执行该方法或代码块。<br>
synchronized 锁升级的过程：无锁 → 偏向锁 → 轻量级锁 → 重量级锁<br>
1. 无锁状态，对象的Mark Word中存储了对象的哈希码、GC信息等，无锁状态（01）。
2. 偏向锁：当只有一个线程获取锁时，会将对象的Mark Word中的线程ID设置为当前线程的ID，同时将对象的状态设置为偏向锁（01）。 第一个访问的线程通过CAS将Mark Word中的线程ID替换为自己的ID。之后该线程进入同步块只需检查线程ID是否匹配，匹配则直接执行，不匹配说明有竞争，升级为轻量级锁。
3. 轻量级锁：当有多个线程同时获取锁时，偏向锁会升级为轻量级锁。轻量级锁使用CAS操作来尝试获取锁，如果成功则将对象的Mark Word中的线程ID设置为当前线程的ID，同时将对象的状态设置为轻量级锁（00）。失败则自旋尝试，自旋超过阈值或第三个线程来竞争，升级为重量级锁。
4. 重量级锁：当有多个线程同时获取锁时，轻量级锁会升级为重量级锁（10）。重量级锁使用操作系统的互斥量来实现，当一个线程获取锁时，会阻塞其他线程的访问。

Java 中的 Lock 接口是 Java 并发包 (java.util.concurrent.locks) 中提供的一个比内置 synchronized关键字更灵活的线程同步机制。
Lock提供了显式的锁机制，使用 Lock 时必须手动释放锁，通常在 finally 块中调用 unlock() 以确保锁被释放。

- synchronized是内置锁，是JVM 层面实现；而Lock是显式锁，是Java API层面的实现。
- synchronized隐式获取锁和释放锁；而Lock必须显式调用 lock() 和 unlock()。
- synchronized是自阻塞式获取锁，不能中断；而Lock可以尝试获取锁，可以中断，可以超时。
- synchronized默认是非公平锁；ReentrantLock可以配置公平和非公平。
- 在JDK1.5时，Lock性能明显优于synchronized；在JDK1.6以后，synchronized 引入偏向锁、轻量级锁等优化后，两者性能接近。在高竞争场景中，ReentrantLock的表现更好。



### 什么是乐观锁和悲观锁？

**悲观锁**：认为并发冲突一定会发生，先加锁再访问。如Java的内置锁（如synchronized、ReentrantLock），数据库行锁等。 悲观锁适合冲突频率高，需要保证强一致性的场景。<br>
**乐观锁**：认为并发冲突很少发生，先操作再检查冲突。无锁机制，如CAS算法、版本号机制、MVCC等。乐观锁适合冲突频率低，读多写少的场景。<br>

CAS(Compare And Swap)的ABA问题：<br>
线程1读取变量值为A，线程2将值改为B，又改回A。线程1的CAS操作仍然成功。<br>
解决方案：增加版本号或时间戳

## 数据库及索引优化

### 索引类型有哪些？
按照逻辑分类：唯一索引、普通索引、主键索引、联合索引、全文索引等 <br>
按照数据结构可以分为：B树索引、B+树索引、hash索引、位图索引、倒排索引等

**哈希索引**适合之做等值查询的数据，不支持范围查询和排序<br>
**位图索引**：Bitmap，是一种特殊类型的数据库索引结构，使用二进制位图表示数据是否存在，能够提供极高的查询效率，和极小的储存空间占用。适用于列的状态值很少，例如性别。<br>
**全文索引**采用倒排索引数据结构：建立"词元→文档位置"的映射关系，适合文章、大文本内容。<br>

### 联合索引与最左匹配原则
**联合索引**，也称复合索引，是在多个列上创建的索引结构。一个索引包含多个列，这些列按照特定的顺序排列。<br>
**最左匹配原则**：查询必须使用索引的最左侧列才能充分利用索引。<br>
最左匹配原则的原因是因为B+树索引的物理存储结构<br>
当创建ABC联合索引时，B+树首先按照A字段排序，a相同则按照B字段排序，b相同则按照c字段排序。
所以，只有最左索引A在全局有序，B字段仅在A字段相同时才有序。<br>
这种结构决定了必须从最左列开始查询才能利用索引的有序性，如果跳过A字段或者中间字段，则无法利用索引的有序结构快速定位数据。<br>
查询顺序不是依次按照联合索引字段顺序查询，或者对最左列字段进行范围查询（>、<）都会导致最左匹配失效<br>


### 什么是聚簇索引和非聚簇索引
**聚簇索引**是一种将数据存储和索引合为一体的索引方式。每张表只能有一个聚簇索引，因为数据的存储顺序只能按照一个索引排列，主键默认作为聚簇索引。<br>
**非聚簇索引**是一种索引与数据分离的索引方式，索引存储的是数据的位置(指针或主键值)而非数据本身。查询时需要"回表"操作，即先通过索引找到指针，再访问数据文件。

聚簇索引和非聚簇索引都可以通过B+树索引实现。
### 什么是覆盖索引？
**覆盖索引**是指一个索引包含了查询所需的所有数据列，使得查询可以完全通过索引完成，而无需访问数据表本身。<br>
核心特征：避免了回表查询。查询所需数据可以直接从索引结构中获取，不需要回表访问数据库。减少了IO操作，减少磁盘访问，提高查询效率。
### 索引失效的场景
1. 违反最左匹配原则：使用联合索引时未从最左列开始，或者跳过中间列，导致索引失效
2. 对索引列使用函数或运算操作，运算后的值无法直接匹配索引结构
3. Like模糊查询时通配符在前，导致索引失效
4. 使用Or连接，使用不等于或大于小于操作符，都会导致索引失效，全表扫描
5. 隐式类型转换：varchar字段使用了数字比较

使用explain查看执行计划，查看TYPE列，是否使用索引，如果是ALL表示全表扫描

### 你是如何设计索引的？
1. 对频繁查询的列创建索引，对where、join、order by、group by 子句中频繁出现的列创建索引
2. 避免对更新频繁的列创建索引，维护索引会带来额外的开销
3. 避免对包含null值过多的列创建索引
4. 对于大文本Blob类型，考虑使用前缀索引或者全文索引替代
5. 创建联合索引时要注意最左匹配原则，将高频查询和高区分度的列放在最左列

### 如何优化数据库查询？

首先分析是否有查询索引失效的情况。<br>
如果没有创建索引，可以为查询字段创建索引。<br>
为查询创建覆盖索引，避免回表查询。

### MySQL里有哪些日志？
1. error log:记录MySQL服务器启动、运行和停止过程中的错误信息
2. binlog:记录所有更改数据的SQL语句(DDL和DML),用于主从复制(Replication),记录的不是简单的SQL文本，而是事件(Events)
3. query log:记录所有到达MySQL服务器的SQL语句,对性能有影响，通常只在调试时开启
4. slow query log:记录执行时间超过指定阈值的SQL语句,用于发现和优化性能瓶颈,可记录未使用索引的查询
5. redo log :确保事务的持久性,用于崩溃恢复
6. undo log:记录事务发生前的数据状态,用于事务回滚,实现MVCC(多版本并发控制)

主要是redo log和undo log。

### 事务ACID
MySQL MyISAM不支持事务，不支持行锁，是表级锁，不支持外键。<br>
MySQL InnoDB引擎支持事务，支持行锁。<br>

事务特性 ACID：
- 原子性：一组事务，要么全部成功，要么全部失败，MySQL通过undo日志进行回滚，实现原子性，记录事务未提交前的状态，失败时回滚。
- 一致性：事务执行前后，数据库必须冲一个一致性状态，转换到另一个一致性状态。例如转账前后两个账户的金额应该保持不变。
- 隔离性：事务之间相互隔离，互不影响。MySQL通过MVCC（多版本并发控制）和锁机制实现，有四种隔离级别。
- 持久性：事务一旦移交，对数据的改变是永久的。即使数据库崩溃，MySQL可以通过redo日志重新恢复数据。

### 事务的隔离级别以及或有哪些问题？
- 脏读（读未提交）：一个事务可能读取另一个事务未提交的数据，造成脏读（另一个数据可能回滚）。
- 不可重复读：同一事务内多次读取同一个数据结果不同。
- 幻读：同一事物内多次查询结果集行数不同。

四种事务隔离级别：
- read uncommited 读未提交，可能脏读、不可重读读和幻读， 
- read commited   读已提交，避免脏读，可能出现不可重读读和幻读，Oracle默认的隔离级别。
- repeatable read 可重复读，避免脏读和不可重复读，可能幻读，    MySQL默认的隔离级别
- serializable    串行化，避免脏读、不可重复读和幻读，避免所有问题，但是性能最低


### 什么是MVCC？

MVCC（Multi-Version Concurrency Control）是一种数据库并发控制技术，它通过维护数据的多个版本来实现非阻塞的读操作，从而显著提高数据库系统的并发性能。

工作方式：每条记录维护多个历史版本。<br>
读操作看到的是特定时间点的数据快照。读操作不需要加锁，不与写操作冲突。<br>
写操作创建新版本，不影响正在进行的读操作。
版本存储位置undo日志

局限性：
存储开销大，需要维护多个版本数据。需要定期清理旧版本。


### B树与B+树
**B树**一种多路平衡查找树，专门为磁盘设计，节点是全局有序的。<br>
**B+树**是B树的一种变体，节点全局有序，范围查询高效，B+树的所有数据都存储在叶子节点，非叶子节点只存储键值和子节点指针，B+树的查询效率更加稳定，每次查询都要走到叶子节点。<br>

为什么使用B+树作为索引存储结构？<br>
B-Tree和B+Tree在数据存储位置上有本质区别：B树所有节点都存储数据，而B+树只有叶子节点存储数据。<br>
B-Tree：每个节点既存储键值(key)也存储实际数据(data)，数据分布在整棵树的所有层级；<br>
B+Tree：只有叶子节点存储完整数据记录，非叶子节点仅存储键值和子节点指针，所有叶子节点通过双向链表连接，形成一个有序的数据序列。<br>
这种设计使得B+Tree的非叶子节点可以容纳更多索引项，显著降低了树的高度。对于相同规模的数据，B+Tree通常比B-Tree更"矮胖"，磁盘I/O次数更少。<br>
B+Tree所有的叶子节点通过指针形成双向链表，只需对链表扫描，不需要回溯到上层节点，只需遍历叶子节点链表即可获取全部数据。<br>
所以B+树查询更加高效，而B-Tree进行范围查询时需要频繁地在不同层级的节点间跳转，效率明显较低。

## JVM Java虚拟机


### JVM内存区域
JVM内存区域主要分为线程共享区域和线程私有区域两大类。
1. 程序计数器：记录当前线程执行的字节码行号指示器。线程私有，每个线程都有自己的程序计数器。
2. 虚拟机栈：存储栈帧（Frame），包括：局部变量表（基本数据类型、对象引用）、操作数栈、动态链接、方法返回地址。
3. 本地方法栈：为Native方法服务。HotSpot将Java虚拟机栈和本地方法栈合并。
4. 堆 Heap：存储对象实例和数组。最大的一块内存区域，是GC主要工作区域。可进一步划分为新生代和老年代，新生代又划分为Eden区和两个Survivor区。堆是线程共享区域。
5. 方法区：存储类信息、常量、静态变量、JIT编译后的代码等。是线程共享的。JDK7及之前实现是永久代，JDK8后实现是元空间（Metaspace，使用本地内存）。运行时常量池也是方法区的一部分。

直接内存（Direct Memory），不属于JVM运行时数据区。通过Native函数库直接分配的堆外内存。使用场景：NIO的DirectByteBuffer。避免Java堆与Native堆间数据拷贝。

### 堆Heap与栈Stack的区别
- 堆内存主要存储对象实例、数组；栈内存主要存储方法调用栈帧。
- 堆内存线程共享。栈是线程私有的。
- 堆内存是JVM中最大的一块区域；而栈内存较小，一般是1MB。
- 堆内存是多个不连续的内存块组成的，用指针寻址，访问速度较慢；而栈是一块连续的内存块，直接栈指针访问，速度极快。
- 堆内存需要GC管理，会产生内存碎片；而栈内存自动释放，无需GC，无碎片。
- 堆的配置参数 -Xms(初始堆大小),-Xmx（最大堆大小）; 栈 -Xss（栈大小，默认1MB）

### 常见的垃圾回收算法
1. 标记-清除算法（Mark-Sweep）：标记阶段：从GC Roots出发，标记所有可达对象。清除阶段：回收未被标记的对象内存。实现简单，但是会产生内存碎片。适用老年代回收。
2. 标记-整理算法（Mark-Compact）：标记存活对象，将存活对象向一端移动，清理边界外内存。无内存碎片，内存利用率高。但是移动对象成本高。适用老年代回收。
3. 复制算法（Mark-Copy）：将内存分为大小相等的From和To空间，将From区存活对象复制到To区，清空整个From区。无内存碎片，效率高，但是内存利用率低。适用于新生代。

分代收集算法：新生代98%对象朝生夕死，使用复制算法；老年代对象存活率高，使用标记-清除/整理算法。

### 常见的垃圾收集器与区别
- Serial GC 串行收集器：单线程执行垃圾回收，使用单核或者内存较小的环境。
- Parallel GC 并行收集器：多线程执行垃圾回收，缩短回收时间。
- CMS 并发标记清除收集器：以低停顿为目标，采用并发标记和清理，减少停顿时间。会产生内存碎片。已被逐步淘汰（JDK14移除）。
- G1 (Garbage First)垃圾回收器：将堆内存划分为多个大小相同的区域，优先回收垃圾最多的区域。避免内存碎片。平衡吞吐量和低延迟，取代CMS，JDK9之后成为默认收集器。
- ZGC (Z Grabage Collector)垃圾回收器：是Java新一代的低延迟垃圾收集器，亚毫秒级停顿（<10ms），支持超大堆（TB级）。适合超大堆，严格低延迟要求的场景。需要手动开启。

### 类加载流程
类加载过程分为五个阶段：
1. 加载：加载由类加载器（ClassLoader）完成，通过类的全限定名（包名+类名），将类的字节码文件加载到内存中。
2. 验证：验证字节码文件的正确性，防止恶意代码破坏JVM。
3. 准备：为类的静态变量分配内存，并设置默认初始值。
4. 解析：将常量池中的符号引用转换为直接引用。
5. 初始化：为类的静态变量赋予正确的初始值。执行类的静态代码块和静态变量的赋值操作。

加载（Loader）由类加载器（ClassLoader）完成，JVM提供了3种默认的类加载器：
1. 启动类加载器（Bootstrap ClassLoader）：加载JAVA_HOME/lib下的核心类（如java.lang.*）。
2. 扩展类加载器（Extension ClassLoader）：加载JAVA_HOME/lib/ext下的扩展类。
3. 应用程序类加载器（Application ClassLoader）：加载用户程序的类（classpath下的类）。
4. 自定义类加载器：用户可以自定义类加载器，用于加载自定义的类。


### 双亲委派模型以及作用
类加载器采用双亲委派机制：当一个类加载器收到加载请求时，它首先委托给父类加载器去加载。只有当父类加载器无法加载时，子类加载器才会尝试加载。

为什么采用双亲委派模型？
1. 保证核心类的安全：防止用户自定义的类（如java.lang.String）替换JVM核心类，避免破坏JVM稳定性。
2. 避免类的重复加载：如果父类加载器已经加载了某个类，子类加载器就不会再加载，避免同一个类被多次加载到内存中。
3. 保证类的唯一性：由于类是由加载它的类加载器+类全限定名共同决定的，双亲委派模型确保了核心类只会被Bootstrap ClassLoader加载一次，避免不同类加载器加载同一个类导致冲突。

在某些特殊情况下，可能需要打破双亲委派模型，例如：
Tomcat的Web应用类加载器：每个Web应用有自己的WebAppClassLoader，它优先加载自己的类，而不是委托给父类加载器，避免不同Web应用的类冲突。

### 你有JVM调优经验吗？如何排查OOM？
通过error log确认OOM类型，是堆内存溢出还是元空间、线程栈溢出，或者是GC回收导致。<br>
首先添加JVM参数获取heap dump日志和gc日志：
`-XX:+HeapDumpOnOutOfMemoryError ` ,`-XX:+PrintGCDetails`。<br>
查看GC日志，分析Full GC的频率和停顿时间。调整堆内存大小以及新老年代比例等。使用合适的垃圾收集器。<br>
优化业务代码，减少大对象或长生命周期对象的创建以及避免内存泄漏。<br>

内存参数优化：
- 设置 -Xms 初始堆和-Xmx最大堆一致，避免堆动态扩展。
- 设置-XX:MetaspaceSize 和 -XX:MaxMetaspaceSize 配置元空间大小。
- 设置-XX:NewRatio=2 老年代:新生代=2:1；
- -XX:SurvivorRatio=8，Eden:Survivor=8:1:1；
- -XX:MaxTenuringThreshold=15 晋升老年代年龄。避免对象过早的进入老年代区域，导致老年代空间不足，频繁Full GC。
- -XX:+UseG1GC 使用G1收集器；

## HTTP状态码
这个有时也会问到。

- 200 请求成功
- 201 请求成功，Created 并且服务器成功创建了新资源，常用于POST请求
- 202 请求接受，但是尚未处理完成，异步处理
- 204 请求成功，但是响应中没有内容，常用于DELETE请求

3xx（重定向状态码）
- 301 重定向，资源已永久移动到新位置，浏览器会自动跳转
- 302 重定向，资源临时移动到新位置，浏览器会自动跳转
- 303 重定向，请求的资源已被永久移动到新位置，客户端应当使用新的URL重新发起请求
- 304 资源未修改，浏览器会从缓存中获取

4xx（客户端错误状态码）
- 400 Bad Request 请求参数错误
- 401 Unauthorized 需要身份验证（未提供或认证失败）
- 403 Forbidden 禁止访问，服务器理解请求客户端的请求，但是拒绝执行此请求（无权限访问）
- 404 Not Found 资源不存在
- 405 Method Not Allowed 请求方法不被允许
- 406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求
- 408 Request Timeout 请求超时
- 413 Request Entity Too Large 请求实体过大，服务器无法处理
- 414 Request-URI Too Long 请求的URI过长（超过服务器的限制）
- 415 Unsupported Media Type 不支持的媒体类型
- 429 Too Many Requests 客户端发送请求过多，服务器拒绝处理

5xx（服务器错误状态码）
- 500 Internal Server Error 服务器内部错误
- 502 Bad Gateway 网关错误
- 503 Service Unavailable 服务不可用，服务器暂时过载或维护，例如超过Tomcat最大连接数
- 504 Gateway Timeout 网关超时，服务器作为网关或代理，未及时从上游服务器收到请求
- 505 HTTP Version Not Supported HTTP版本不支持

## Spring框架

### 为什么要使用Spring？SpringBoot框架开发？
Spring框架解决了企业级开发的痛点，传统J2EE问题：容器笨重复杂，代码侵入性强，测试困难，部署依赖应用服务器。

Spring IOC和DI，控制反转与依赖注入，解耦组件关系，提高可测试性。Spring AOP面向切面编程，分离与业务无关的代码，提高代码的复用性，更加灵活。Spring声明式事务，简化事务代码，提高开发效率。
SpringBoot基于约定和条件化配置，减少90%以上的显式配置。内置Tomcat/Jetty，无需部署WAR包，快速运行。提升Java企业级应用的开发效率。

### Spring IOC
IOC(Inversion of Control)控制反转 是面向对象编程中的一种设计原则，也是Spring框架的核心思想之一，用于降低代码之间的耦合度。将创建对象的将控制权交给容器来管理。

IOC可以降低代码耦合，提高代码复用性避免重复创建。

`DI`(Dependency Injection)依赖注入是`IOC`的一种实现方式，通过构造函数、Setter 方法或字段注入依赖对象。

### Spring AOP以及实现原理 
AOP(Aspect-Oriebted Programming)是面向切面编程，是一种编程范式，是对OOP的补充。<br>
它能够将一些与业务无关的代码从业务代码中分离出来，从而提高代码的复用性和可维护性。<br>
AOP的优点：代码解耦，将横切关注点与业务逻辑分离；提高代码的复用性；灵活性。<br>
AOP适用场景：日志记录、事务管理、权限控制、异常处理等

Spring AOP 基于动态代理实现：具体分为两种方式：<br>
**JDK动态代理**：只能代理接口，Spring AOP默认使用JDK动态代理。使用反射实现动态代理<br>
**CGLIB动态代理**：可以代理类，也可以代理接口，当Bean没有实现接口时，Spring AOP会使用CGLIB动态代理。使用字节码技术生成一个新的类，该类继承自目标类，并重写其中的方法。

### Spring Bean的生命周期
1. 实例化：通过反射机制调用Bean的构造函数创建Bean实例。
2. 属性注入：Spring通过依赖注入（DI）为Bean的属性赋值（如@Autowired、@Value等）。处理setter注入或字段注入。
3. Aware接口回调（可选实现）：如果Bean实现了Spring的Aware接口（如ApplicationContextAware、BeanNameAware等），则会回调这些接口方法（setBeanName()/setBeanFactory()）。
4. BeanPostProcessor前置处理（postProcessBeforeInitialization）：所有BeanPostProcessor的`postProcessBeforeInitialization()`方法会被调用。
5. 初始化：Spring会调用afterPropertiesSet()。如果配置了`init-method`（如@Bean(initMethod = "init")或XML中的init-method），Spring会调用该方法。
6. BeanPostProcessor后置处理（postProcessAfterInitialization）：所有BeanPostProcessor的p`ostProcessAfterInitialization()`方法会被调用。

Bean完全初始化后，存入Spring容器（ApplicationContext），供其他Bean或代码调用。

7. Bean销毁阶段: 调用`@PreDestroy` 注解方法。 或者调用`destroy()`。或者XML中的destroy-method。

Spring 管理 Bean 的整个生命周期，从创建实例到填充属性、初始化、销毁。

### Spring如何解决循环依赖
Spring 通过三级缓存解决循环依赖问题<br>

什么是循环依赖？<br>
当两个或者多个Bean互相依赖时形成循环：Bean A 内部依赖的 Bean B属性，而 Bean B 内部有依赖的 Bean A属性。

三级缓存结构：
- singletonObjects （成品对象）：单例池，存放已经实例化的单例Bean
- earlySingletonObjects （半成品对象）：提前暴露的单例池，存放已经实例化但还未完成属性注入的单例Bean（早期引用）。
- singletonFactories：对象工厂，存放单例Bean的工厂方法，用于生成代理对象

**早期引用**：早期引用是指 Spring 在 Bean 完成完全初始化之前（即还在属性填充和初始化过程中）就提前暴露出来的对象引用。这种机制是 Spring 解决循环依赖的核心技术。

注意，当从三级缓存获取ObjectFactory并生成早期引用之后，需要把ObjectFactory从三级缓存中移除，保证每个 Bean 的 ObjectFactory 只被调用一次，避免内存泄漏，维护缓存一致性。

### Spring MVC的流程

现在基本都使用SpringBoot开发，使用Spring MVC开发的比较少，但是还是有一次被问到了。

Spring MVC 的核心流程围绕 前端控制器（DispatcherServlet） 展开，将请求分发给对应的处理器（Controller），并最终渲染视图返回给客户端。

1. 首先请求到达 DispatcherServlet 前端控制器：所有的HTTP请求首先有DispatcherServlet 接收，它是Spring MVC的核心调度器。
2. 调用 HandlerMapping 处理器映射器：DispatcherServlet 会调用 HandlerMapping 处理器映射器，根据请求的URL找到对应的处理器（Controller）。
3. 调用 HandlerAdapter 处理器适配器：DispatcherServlet 通过 HandlerAdapter（处理器适配器）调用具体的Controller方法。
4. 执行Controller方法：HandlerAdapter 使用 ArgumentResolver（参数解析器）解析方法参数（如 @RequestParam、@RequestBody 等）。返回结果（ModelAndView）
5. 处理返回值：
   -  ViewResolver 视图解析器 解析视图（将逻辑视图名转换为实际视图），渲染视图（使用模型数据渲染视图）：使用模型（Model）渲染视图（View），将Model中的数据填充到视图中；
   - 或者直接响应数据，使用 HttpMessageConverter 将返回值转换为JSON/XML等格式，直接写入响应流。
6. 返回响应给客户端：DispatcherServlet 将处理结果返回给客户端。


## Redis

### Redis为什么快？
1. 基于内存操作：Redis将数据存储在内存中，而内存的读写速度远高于磁盘，使得Redis能够避免磁盘I/O的瓶颈，直接通过内存操作实现每秒数十万甚至百万级的操作。
2. 单线程模型：避免锁竞争和上下文切换。
3. I/O多路复用模型：Redis使用系统提供的多路复用器（如epoll）作为事件监听器，监听所有连接的可读或可写事件。

### Redis基本数据类型
- String 字符串：是Redis最基本的数据类型，可以存储文本、整数或二进制数据，最大可存储512MB。常用场景缓存：存储频繁访问的数据如网页内容、API响应等，减轻数据库压力，分布式锁：通过SETNX(SET if Not eXists)命令实现简单的分布式锁。
- Hash 哈表：哈希类型是字段与值的映射表，特别适合存储对象。使用场景：存储用户信息、商品信息等，方便快速查询
- List：列表是按插入顺序排序的字符串集合，支持从两端推入或弹出元素。可以实现简单的消息队列系统。
- Set：集合是无序且唯一的字符串集合，提供高效的添加、删除和判断元素存在性操作。适用场景：唯一性集合，存储不重复的元素、社交网络，存储好友关系，使用SINTER计算共同好友、SADD实现添加好友等。
- Zset：有序集合，每个成员都关联一个分数(score)，用于排序。成员是唯一的(去重)，但分数可以重复。适用场景：排行榜、优先队列、时间线：使用时间戳作为分数，实现按时间排序的消息流。



### 什么是缓存穿透、缓存击穿和缓存雪崩以及解决方案
1. 缓存穿透（数据不存在）：用户不断请求缓存和数据库中都`不存在的数据`。例如请求ID为-1或特别大不存在的数据，每次请求都绕过缓存直接访问数据库，导致数据库压力过大。
    解决方案：布隆过滤器 Bloom Filter：将所有可能存在的数据哈希到一个足够大的bitmaps中，一个一定不存在的数据会被这个bitmaps拦截掉，从而避免了对不存在的数据进行查询。

2. 缓存击穿（单个数据过期）：**某个**热点key在失效的瞬间，大量并发请求同时访问这个key，导致所有请求都落到数据库上，造成数据库瞬时压力过大。
    解决方案：
     - 设置热点数据永不过期：对极热点数据不设置过期时间
     - 使用分布式锁：当数据过期时，使用分布式锁来保证只有一个线程去数据库查询数据并回填缓存。

3. 缓存雪崩（大量数据过期）：**大量**key在同一时间失效，导致大量请求直接访问数据库，造成数据库压力过大。
    解决方案：
     - 随机过期时间：为每个key设置不同的过期时间，避免同一时间大量key失效。
     - 热点数据永不过期：对极热点数据不设置过期时间。
     - 缓存预热：在系统启动时，将热点数据提前加载到缓存中。

### 布隆过滤器 Bloom Filter
布隆过滤器（Bloom Filter）是一种高效的概率型数据结构，用于快速判断一个元素是否可能存在于一个集合中。
空间效率高，查询速度快。
存在误判率：可会误判不存在的元素存在；但是不会误判存在的元素为不存在。

核心原理是使用 位数组：布隆过滤器使用一个长度为 m 的二进制位数组（初始全为 0）存储数据。
使用k个不同的哈希函数，每个函数将输入元素映射到位数组的某个位置。
对元素进行k次哈希，得到k个位置，将这些位置这是为1

查询元素时，对元素进行k次哈希，检查对应的k个位置是否都为1.
如果全部为1，可能存在；（可能误判）
如果有一个为0，一定不存在。
即如果不存在就是不存在！无漏判。
     
### Redis如何实现分布式锁？

Redis实现分布式锁通过`SETNX`实现，`SET lock_key unique_value NX PX 30000`。
仅当Key不存在时设置，30秒自动过期，防止死锁，value为唯一标识，避免被其他线程删除。
注意加锁和过期时间的原子性。Redis提供了原生的SETNX命令保证SET和EXPIRE操作的原子性。
也可以使用LUA脚本保证Redis命令的原子性。

生产级解决方案：Redisson实现。支持看门狗机制，自动续期（默认30秒，每10秒续期）

### 如何保证缓存数据一致性
1. 可以使用缓存**延迟双删**保证缓存数据最终一致性问题，但是会有短暂窗口不一致。
先更新DB，删除缓存，延时再次删除缓存，实现最终一致。
并发情况下，线程A的DB操作还未完成（事务未提交），删除缓存，线程B此时缓存未命中，重新从DB中读取旧数据回填缓存，导致脏读，通过延时（如200ms）二次删除缓存保证数据最终一致性。

2. 使用分布式锁实现强一致性。
当更新缓存数据时，使用分布式锁，保证当前只能有一个线程读写缓存key，等更新DB和缓存完成后，在释放锁。


## MQ消息队列

### 如何保证消息的可靠性？
以Kafka为例：<br>
生产者端通过消息确认机制（ACKS）保证消息成功投递到Broker队列。<br>
Broker端设置副本并配置持久化，将消息写入磁盘。<br>
消费确认机制，消费成功后，手动提交offset偏移量。

Kafka的可靠性需要生产者、Broker和消费者三端协同保障

### 如何保证消息不被重复消费？
消费端幂等性设计：无论消费多少次，结果都一样，不影响业务状态。使用数据库的唯一约束，插入数据时先判断记录是否存在。重复插入会抛出异常。

使用消息ID去重：消息中带有唯一ID（如UUID、订单号、traceId），消费前判断该消息ID是否已处理，处理过就丢弃。

消费成功后手动提交akc或者offset，避免“消费成功但没提交”的问题。

### 如何保证消息的顺序性？
在kafka中，partition分区内部的消息是有序的，但是多个Partition之间是无序的。按消息的 Key 分区（Partition）发送：将具有相同业务标识（如订单ID）的消息发送到同一个分区（Partition）。消费端针对每个分区单线程消费或按照消息顺序依次处理。

一个 Partition 同时只能被一个消费者消费（不允许多个消费者并发消费同一个Partition）
## Zookeeper如何实现分布式锁？
Zookeeper通过创建临时顺序节点实现分布式锁。<br>
客户端获取`/locks`下的所有子节点，并按节点编号排序。<br>
如果当前节点编号最小，则获得锁；否则，监听前一个节点的删除事件。<br>
当业务逻辑完成后，删除当前节点，释放锁。<br>
客户端连接断开或网络异常时，临时节点会自动删除，释放锁。

ZooKeeper的临时顺序节点会为每个客户端创建的节点自动附加一个全局递增的序号（如lock-00000001、lock-00000002）。通过判断当前节点是否是最小编号节点，可以确保先到先服务的公平性。

客户端创建的临时节点在会话结束后会自动删除，避免死锁

## 设计模式
你业务开发中有用到哪些设计模式？

- 单例模式：直接使用Spring创建的对象默认都是单例模式。
- 建造者模式：复杂对象的创建。例如Java里的StringBuilder。
- 装饰器模式：缓存+数据库的查询服务。先查缓存，如果缓存没有在查询数据库，回填缓存。或者日志装饰器。
- 适配器模式：新老方法系统适配兼容
- 策略模式：比如定义支付方式接口，实现支付宝和微信两种支付方式。
- 责任链模式：业务设计审批流程的场景。
- 工厂模式：比如报表生成器，可以返回PDF、EXCEL、CSV等不同格式的报表生成器

## NIO
NIO有了解过吗？

NIO是Java提供的高性能非阻塞I/O模型。与传统BIO（同步阻塞I/O模型）相比，它通过三大核心组件实现了非阻塞、事件驱动的网络编程模型。
1. Channel 通道：双向通信，可同时读写（区别于BIO的单向流）。
2. Buffer 缓存区：数据缓冲区。
3. Selector 选择器：多路复用，单线程管理多个Channel

传统的BIO模型是同步阻塞模型，线程模型是1:1；而NIO是非阻塞模型，线程模型是1:N。

NIO的核心优势：
1. 高并发支持：单线程可处理数万连接。
2. 零拷贝技术：`FileChannel.transferTo(position, count, targetChannel);`
3. 内存管理：直接内存（DirectBuffer）减少JVM堆拷贝；Buffer池化技术降低GC压力

NIO空轮询Bug：Linux epoll导致select()立即返回，Netty修复了NIO空轮训Bug。

Netty是一个异步事件驱动的网络应用框架，用于快速开发高性能、高可靠性的网络服务器和客户端。基于Java NIO（非阻塞I/O）实现。

定义两个EventLoopGroup（bossGroup和workerGroup），用于处理网络连接和处理IO。
一个EventLoop处理多个Channel

Netty简化了NIO复杂性，封装了Java NIO的底层细节，如Selector管理，拆包粘包，提供更易用的API。
内置HTTP、WebSocket等协议编码器，支持自定义协议。

Netty零拷贝是一种减少数据拷贝次数的优化技术，旨在提升数据传输效率，降低CPU和内存开销，尤其适用于高性能网络通信和大文件传输场景。
- 直接缓冲区（Direct Buffer）：避免数据在JVM堆和Native堆之间复制，直接在Native堆中分配内存。
- 组合缓冲区（Composite Buffer）：将多个ByteBuffer合并为一个，避免多次复制。
- 文件传输零拷贝：使用FileRegion代替传统的read/write方法，避免数据复制到用户态。


Netty典型应用场景：
- 分布式系统：如Dubbo、RocketMQ的底层通信
- 即时通讯：支持WebSocket、HTTP长连接，适用于聊天服务器
- 游戏服务器：处理低延迟、高并发的实施交互
- 大数据与物联网：如Hadoop的RPC框架

## 高并发系统设计
- CDN 内容分发网络，通过将内容分发到全球各地的边缘节点，使用户可以就近获取所需内容，显著提升访问速度和稳定性。例如：静态内容加速：缓存图片/CSS/JS等不变资源，网站静态资源
- 缓存：设置多级缓存，提高查询速度，减小数据库查询压力。
- 消息队列：使用消息队列异步削峰。
- 服务限流降级：使用Sentinel对热点参数限流，配置熔断策略。
- 弹性伸缩设计：使用K8s HPA实现服务弹性扩缩容。
- 关键指标监控告警：使用Prometheus + Grafana监控服务关键指标，配置告警通知。


## 算法
有些公司会考察算法。
建议大家有空可以多刷一下LeetCode Hot 100.

常见的数据结构：
- 数组
- 链表
- 位图
- 二叉树


常见算法解决思路：
- 哈希表
- 双指针
- 滑动窗口
- 贪心算法
- 动态规划


算法问题不是一朝一夕能够速成的，重在平常的积累。

## AI
现在AI发展的很火，我们也需要了解一些AI LLM大模型应用开发的一些内容。AI应用开发经验在很多公司面试中也是加分项。

### RAG Chunk问题
RAG（中的 Chunk（文本分块） 是影响检索效果和生成质量的关键因素，不合理的分块可能导致信息丢失、噪声干扰或语义割裂。

1. 语义不完整：分块割裂了完整语义单元（如将一个句子、表格或列表拆分到不同块）。
2. 上下文信息丢失：分块过小导致关键上下文缺失（如标题、前置定义被分离
3. 冗余与噪声：分块过大或包含无关内容（如广告、页眉页脚），降低检索精度。
4. 多模态内容处理失败：文本分块忽略图片、表格、公式等非文本内容，导致信息不完整。

解决方案：<br>
按自然段落、标点或语义边界分块。<br>
动态添加元数据（如章节标题、关键词）。<br>
将非文本内容转为描述性文本。<br>
结合规则分块（如固定大小）与语义分块（NLP模型分割）。

### 相似性算法
- 欧式距离 L2：欧几里得距离测量连接两点的线段的长度。范围：[0, +∞]，值越小表示相似度越大。缺点：受向量长度影响大，对长文档敏感；高维稀疏时效果差。
- 余弦相似度 COSIN：余弦相似度使用两组向量之间夹角的余弦来衡量它们的相似程度。范围：[0,1]，余弦值越大，两个向量之间的夹角越小，表明这两个向量彼此越相似。

使用COS的好处：
1. 对向量文本长度不敏感，无论向量的长度是多长，余弦相似度的值始终在0到1之间。避免长文档支配相似度计算，更关注内容的相关性。
2. 余弦相似度可以处理高维向量，而欧氏距离只能处理低维向量。
3. 鲁棒性好，对停用词、标点等噪声不敏感。例子：“The cat sat.”和“Cat sat.”的余弦相似度接近1，而欧氏距离因长度差异可能较低。

还有一些其他的相似性算法：IP 内积、JACCARD、BM25等。不展开介绍了。


### RAG评估指标
评估RAG应用的质量需要综合考虑检索（Retrieval）和生成（Generation）两个模块的表现。
1. 上下文精度 Context Precision：检索结果中相关文档的比例。来识别检索的上下文是否相关。
2. 上下文召回率 Context Recall：成功检索到相关文档的比例。更高的召回率表示遗漏的相关文档更少。

3. 答案忠实性：生成答案是否严格基于检索内容，避免模型幻觉。
4. 答案相关性：生成答案是否直接回应问题，避免冗余或偏离。
5. 答案准确性：答案与标准答案的匹配程度

## 口语

如果你要面试外企的话，英语口语是必不可少的一个技能。也是希望大家平常多积累学习。
许多外企一般都要求英语读写流利。


## 总结
大部分面试官还是跟你的简历上内容进行提问的。
首先建议大家熟悉自己简历上的内容，写上去的东西自己一定要收悉，自己不熟悉的内容建议不要写上去，自己说不清楚的内容面试的时候不要自己主动说出来。

大家在复习的时候不要眼高手低，注意细节。
比如面试官可能让你手画出B+树的结构，手写一个设计模式等等细节问题，大家在熟悉概念的同时，也要多熟悉源码和底层原理。
我们除了要知道一个东西是什么？还要知道是为什么？这也是面试官很喜欢问的一个问题。


