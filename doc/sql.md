
## 数据库索引优化

### 索引类型
按照逻辑分类：唯一索引、普通索引、主键索引、联合索引、全文索引等
按照数据结构可以分为：B树索引、B+树索引、hash索引、位图索引、倒排索引等

全文索引采用​​倒排索引​数据结构：建立"词元→文档位置"的映射关系
Hash索引适合之做等值查询的数据，不支持范围查询和排序
全文索引FullText适合文章、大文本内容，
位图索引：Bitmap，是一种特殊类型的数据库索引结构，使用二进制位图表示数据是否存在，能够提供极高的查询效率，和极小的储存空间占用
为每个不同的索引键创建一个位图，每个二进制位对应表中的一行数据，位图中的每一位0或1表示表中某行是否包含该值。
例如性别列有男女两个值，就会生成两个位图，例如对于5行记录，若"男"的位图是10100，表示第1、3行是男性，其余不是。
适用于列的状态值很少

多状态位图表示：
位图索引结构：
CLERK:   10010  (第1、4行是CLERK)
MANAGER: 01001  (第2、5行是MANAGER)
SALES:   00100  (第3行是SALES)

覆盖索引与联合索引：
覆盖索引​是指**一个索引包含了查询所需的所有数据列**，使得查询可以完全通过索引完成，而无需访问数据表本身。
核心特征：避免了回表查询。查询所需数据可以直接从索引结构中获取，不需要回表访问数据库。减少了IO操作，减少磁盘访问，提高查询效率。
通过将查询涉及的列（如Select、Where等子句中的字段）全部包含在索引结构中。

工作原理：
在传统查询中，数据库通常需要先通过索引找到行指针，在回表获取完整的数据。
而覆盖索引则直接通过索引就能获取所有需要的数据，跳过了回表步骤。

联合索引，也称复合索引，是在多个列上创建的索引结构。一个索引包含多个列，这些列按照特定的顺序排列。
最左匹配原则：查询必须使用索引的最左侧列才能充分利用索引


覆盖索引可以通过联合索引实现，但也可以通过单列索引实现。



### 索引失效场景：
1. 违反最左匹配原则：使用联合索引时未从最左列开始，或者跳过中间列，导致索引失效
2. 对索引列使用函数或运算操作，运算后的值无法直接匹配索引结构
3. Like模糊查询时通配符在前，导致索引失效
4. 使用Or连接，使用不等于或大于小于操作符，都会导致索引失效，全表扫描
5. 隐式类型转换：varchar字段使用了数字比较


使用explain查看执行计划，查看TYPE列，是否使用索引，如果是ALL表示全表扫描

B树一种**多路平衡查找树**，专门为磁盘设计，节点是全局有序的
B+树是B树的一种变体，节点全局有序，范围查询高效，B+树的所有数据都存储在叶子节点，非叶子节点只存储键值和子节点指针，B+树的查询效率更加稳定，每次查询都要走到叶子节点

为什么使用B+树作为索引存储结构？
B-Tree和B+Tree在数据存储位置上有本质区别：B树所有节点都存储数据，而B+树只有叶子节点存储数据，
B-Tree​​：每个节点既存储键值(key)也存储实际数据(data)，数据分布在整棵树的所有层级；
B+Tree​​：只有叶子节点存储完整数据记录，非叶子节点仅存储键值和子节点指针，所有叶子节点通过双向链表连接，形成一个有序的数据序列
这种设计使得B+Tree的非叶子节点可以容纳更多索引项，显著降低了树的高度。对于相同规模的数据，B+Tree通常比B-Tree更"矮胖"，磁盘I/O次数更少
B+Tree所有的叶子节点通过指针形成双向链表，只需对链表扫描，不需要回溯到上层节点，只需遍历叶子节点链表即可获取全部数据。所以B+树查询更加高效
而B-Tree进行范围查询时需要频繁地在不同层级的节点间跳转，效率明显较低


红黑树是一种自平衡的二叉查找树，
全局有序，通过中序遍历红黑树，可以得到所有节点的有序序列
红黑树不适合数据库场景，二叉树结构导致高树太高，磁盘IO次数多

总结：
B树所有节点都存储数据，B+树只有叶子结点存储数据，并且通过双向链表连接，非叶子节点只存储键值和子节点指针。
B+树查询更高效，更稳定，相同数据规模下，B+树更加矮胖，磁盘IO次数更少。

### 最左匹配原则
最左匹配原则的原因是因为B+树索引的物理存储结构
当创建ABC联合索引时，B+树首先按照A字段排序，a相同则按照B字段排序，b相同则按照c字段排序。

所以，只有最左索引A在全局有序，B字段仅在A字段相同时才有序
这种结构决定了必须冲最左列开始查询才能利用索引的有序性，如果跳过A字段或者中间字段，则无法利用索引的有序结构快速定位数据。
查询顺序不是依次按照联合索引字段顺序查询，或者对最左列字段进行范围查询（>、<）都会导致最左匹配失效


### 索引设计原则：
对频繁查询的列创建索引，对where、join、order by、group by 子句中频繁出现的列创建索引
避免对更新频繁的列创建索引，维护索引会带来额外的开销
避免对包含null值过多的列创建索引
对于大文本Blob类型，考虑使用前缀索引或者全文索引替代

创建联合索引时要注意最左匹配原则，将高频查询和高区分度的列放在最左列



### 什么是聚簇索引和非聚簇索引？
聚簇索引是一种将数据存储和索引合为一体的索引方式。
每张表只能有一个聚簇索引，因为数据的存储顺序只能按照一个索引排列，主键默认作为聚簇索引。
在InnoDB存储引擎中，聚簇索引基于B+树实现，B+树结构，叶子节点直接存储数据页

非聚簇索引是一种索引与数据分离的索引方式，索引存储的是数据的位置(指针或主键值)而非数据本身
一张表可以有多个非聚簇索引，查询时需要"回表"操作，即先通过索引找到指针，再访问数据文件

聚簇索引和非聚簇索引都可以通过B+树索引实现：
B+树：
叶子节点：存储完整的键值和对应的数据记录
非叶子节点：存储键值和子节点指针

聚簇索引：叶子节点直接存储行数据（索引和数据一体）
非聚簇索引：叶子节点存储键值和主键（索引与数据分离）

B+树的基本概念​​确实规定所有数据存储在叶子节点，但这是​​逻辑层面的设计​​。是否索引与数据一体存储​​取决于具体实现

回表流程：
1. 定位叶子节点，获取索引列值和对应的主键值
2. 使用获得的主键值，在聚簇索引中查找，聚簇索引的叶子节点包含完整的数据行
3. 从聚簇索引叶子节点读取完整数据行，返回给查询引擎

总结，非聚簇索引需要回表查询，首先定位叶子节点，获得索引位置和主键值，在通过主键聚簇索引查询到叶子节点，获取所有数据行信息。

### 慢查询排查
1. 开启慢查询日志 SET GLOBAL slow_query_log = 'ON'
2. 分析慢查询原因，使用EXPLAIN执行计划分析，关键字段解读：
   type：访问类型，性能排序：system > const > eq_ref > ref > range > index > ALL
   key：实际使用的索引，NULL表示未使用索引查询



### MySQL Log
1. error log:记录MySQL服务器启动、运行和停止过程中的错误信息
2. binlog:记录所有更改数据的SQL语句(DDL和DML),用于主从复制(Replication),记录的不是简单的SQL文本，而是事件(Events)
3. query log:记录所有到达MySQL服务器的SQL语句,对性能有影响，通常只在调试时开启
4. slow query log:记录执行时间超过指定阈值的SQL语句,用于发现和优化性能瓶颈,可记录未使用索引的查询
5. redo log :确保事务的持久性,用于崩溃恢复
6. undo log:记录事务发生前的数据状态,用于事务回滚,实现MVCC(多版本并发控制)


## MYSQL事务
MySQL InnoDB引擎支持事务，支持行锁
MySQL MyISAM不支持事务，不支持行锁，是表级锁，不支持外键
Oracle 使用单一的OBT（​Oracle Database Block Organized Table）存储引擎，支持事务
事务特性 ACID：
原子性：一组事务，要么全部成功，要么全部失败，MySQL通过undo日志进行回滚，实现原子性，记录事务未提交前的状态，失败时回滚。
一致性：事务执行前后，数据库必须冲一个一致性状态，转换到另一个一致性状态。例如转账前后两个账户的金额应该保持不变。
隔离性：事务之间相互隔离，互不影响。MySQL通过MVCC（多版本并发控制）和锁机制实现，有四种隔离级别。
持久性：事务一旦移交，对数据的改变是永久的。即使数据库崩溃，MySQL可以通过redo日志重新恢复数据。

MySQL默认自动提交每条SQL语句。

脏读（读未提交）：一个事务可能读取另一个事务未提交的数据，造成脏读（另一个数据可能回滚）。
不可重复读：同一事务内多次读取同一个数据结果不同。
幻读：同一事物内多次查询结果集行数不同。

四种事务隔离级别：
read uncommited 读未提交  可能脏读、不可重读读和幻读， 
read commited   读已提交  避免脏读，可能出现不可重读读和幻读，Oracle默认的隔离级别。
repeatable read 可重复读  避免脏读和不可重复读，可能幻读，    MySQL默认的隔离级别
serializable    串行化    避免脏读、不可重复读和幻读，避免所有问题，但是性能最低

MVCC 多版本并发控制：
共享锁：允许并发读取
排它锁：阻止其他事务读写
间隙锁（gap lock）:防止幻读
临建锁：记录锁+间隙锁组合





# SQL 基础
- DML（数据操纵语言）：SELECT、INSERT、UPDATE、DELETE语句
- DDL（数据定义语言）：CREATE、ALTER、DROP语句
- DCL（数据控制语言）：GRANT、REVOKE语句
- 高级查询：GROUP BY、HAVING、ORDER BY、LIMIT等分组排序操作
- 聚合函数：COUNT、SUM、AVG、MAX、MIN等常用函数

## DDL数据定义语言
```sql
-- 创建数据库
CREATE DATABASE mydb;
-- 删除数据库
DROP DATABASE mydb;
-- 使用数据库
USE mydb;
-- 创建表
CREATE TABLE employee (
    emp_id INT PRIMARY KEY,
    emp_name VARCHAR(50) NOT NULL,
    hire_date DATE,
    age INT,
    salary DECIMAL(10,2)
)
-- 添加新列
ALTER TABLE employee ADD COLUMN department VARCHAR(30);

-- 删除现有列
ALTER TABLE employee DROP COLUMN department;

-- 修改列的数据类型
ALTER TABLE employees MODIFY COLUMN age FLOAT;

-- 重命名列
ALTER TABLE employees RENAME COLUMN age TO employee_age;

-- 添加主键约束
ALTER TABLE 表名 ADD PRIMARY KEY (列名);

-- 添加外键约束
ALTER TABLE 表名 ADD FOREIGN KEY (列名) REFERENCES 另一个表名(列名);

-- 删除约束
ALTER TABLE 表名 DROP CONSTRAINT 约束名;

```

## DQL 数据查询语言
```sql
-- 基本查询
SELECT emp_name, salary FROM employee;

-- 条件查询
SELECT * FROM employee WHERE salary > 5000;

-- 模糊查询
SELECT * FROM employee WHERE emp_name LIKE '张%';

-- 排序
SELECT * FROM employee ORDER BY salary DESC;

SELECT * FROM employee WHERE salary > 5000 

-- 分组统计
SELECT department, AVG(salary) as avg_salary 
FROM employee 
GROUP BY department 
HAVING AVG(salary) > 6000;

```

## FROM、JOIN、WHERE、GROUP BY、HAVING、SELECT、ORDER BY、LIMIT的执行步骤
1. FROM/JOIN: 从指定的表或视图中获取数据。
2. WHERE: 根据指定的条件过滤数据。
3. GROUP BY: 根据指定的列对数据进行分组。
4. HAVING: 对分组后的数据进行过滤。
5. SELECT: 从数据集中选择需要的列。
6. ORDER BY: 根据指定的列对数据进行排序。
7. LIMIT: 限制返回结果的数量。

举例：

```sql
SELECT u.region, SUM(o.amount) AS total_amount
FROM users u
JOIN orders o ON u.user_id = o.user_id
WHERE o.create_time BETWEEN '2025-01-01' AND '2025-12-31'
GROUP BY u.region
HAVING SUM(o.amount) > 10000
ORDER BY total_amount DESC
LIMIT 10;
```


## DML 数据操纵语言
```sql
-- 插入数据
INSERT INTO employee (emp_id, emp_name, hire_date, age, salary) 
VALUES (1001, '张三', '2022-01-01', 25, 5000);

-- 更新数据
UPDATE employee SET salary = 6000 WHERE emp_id = 1001;

-- 删除数据
DELETE FROM employee WHERE emp_id = 1001;
```

## DCL 数据控制语言
```sql
-- 授权
GRANT SELECT, INSERT ON employee TO user1;

-- 撤销权限
REVOKE INSERT ON employee FROM user1;
```




# 数据库的三范式是什么？
1. 第一范式：**字段不可再分**
    - 表中的每一个字段都是原子性的，不可再分，即每一个字段只能存储一个值。
    - 目的是为了消除重复字段和多值字段，让数据结构更规范。
2. 第二范式：**消除部分依赖**
    - 在第一范式的基础上，非主键字段完全依赖主键，不能产生部分依赖。
      举例：不符合2NF（复合主键为 课程号 + 学号）
        | 课程号  | 学号   | 学生姓名 | 成绩 |
        | ---- | ---- | ---- | -- |
        | C001 | S001 | 张三   | 90 |
      
      这里学生姓名只依赖于学号，而不是完整的主键（课程号 + 学号）。
      应该拆成两个表：
        学生表：
        | 学号   | 学生姓名 |
        | ---- | ---- |
        | S001 | 张三   |
        
        成绩表：
        | 课程号  | 学号   | 成绩 |
        | ---- | ---- | -- |
        | C001 | S001 | 90 |

3. 第三范式：**消除传递依赖**
    - 在第二范式的基础上，任何非主键字段不能依赖于其他非主键字段。
    举例：不符合3NF
        | 学号   | 姓名 | 班级ID | 班级名称  |
        | ---- | -- | ---- | ----- |
        | S001 | 张三 | B01  | 一年级一班 |

       班级名称 依赖于 班级ID，而 班级ID 又依赖于 学号（主键）。这是一种传递依赖。
       应拆成：学生表和班级表
        | 学号   | 姓名 | 班级ID |
        | ---- | -- | ---- |
        | S001 | 张三 | B01  |

        | 班级ID | 班级名称  |
        | ---- | ----- |
        | B01  | 一年级一班 |

---
总结
| 范式  | 核心要求        | 主要目的是      |
| --- | ----------- | ---------- |
| 1NF | 字段原子性       | 避免重复与多值字段  |
| 2NF | 非主属性完全依赖主键  | 避免部分依赖     |
| 3NF | 非主属性不传递依赖主键 | 避免传递依赖，去冗余 |

但是在实际项目中，我们会在范式与性能之间做权衡，视业务场景进行适当反范式设计。

# 数据库事务与锁机制
- ACID：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）
- 事务隔离级别：读未提交（Read Uncommitted）、读已提交（Read Committed）、可重复读（Repeatable Read）、串行化（Serializable）
- 锁机制：行锁、表锁、间隙锁、临键锁



## 索引的存储结构
索引的主要数据结构：
- B-Tree
- B+Tree(MySQL主要使用的结构)
- Hash哈希索引
- Full-text全文索引

### B-Tree B树
B树是多路平衡查找树
- 所有叶子节点位于同一层，
- 每个节点包含`键值`和`指向数据的指针`。

### B+Tree B+树
B+树是在B树的基础上进行优化的一种数据结构。
- `非叶子`节点只存储`键值`，**不存储数据**
- `叶子`节点存储所有**键值**和**数据指针**
- `叶子`**节点通过指针连接形成链表**

InnoDb默认使用B+Tree索引


聚簇索引(Clustered Index)和非聚簇索引(Non-Clustered Index)是数据库中两种重要的索引类型，它们在数据存储方式和查询性能上有显著差异
聚簇索引：是一种​​将数据存储与索引结合​​的索引类型，叶子节点包含整行数据。​

在InnoDB中，​主键索引是聚簇索引​​，直接存储数据，其他索引都是非聚簇索引​​，需要回表查询。




# 数据库性能优化
## 索引优化

- 索引类型：B+树索引结构原理、聚簇索引与非聚簇索引的区别
- 索引设计：组合索引的最左前缀原则、覆盖索引、索引选择性计算
- 索引失效场景：函数操作、类型转换、LIKE模糊查询等导致索引失效的情况
- 索引优缺点


## 最左匹配原则？为什么是最左匹配
最左匹配原则是指在使用联合索引(复合索引)时，MySQL会从索引的最左边字段开始向右匹配，只有查询条件中包含了联合索引的第一个字段(最左字段)，索引才会被使用。如果查询条件不包含最左字段，索引将失效。

为什么是从最坐匹配？
这与索引的底层数据结构(B+树)和存储方式直接相关：
1. B+树索引的排列方式，联合索引在B+树中的存储结构是：先按第一个字段排序，第一个字段相同的情况下，按第二个字段排序
2. B+树索引使用二分查找，必须有序才能高效查找。如果不从最左字段开始，后续字段在索引中是无序的

如何设计高效的联合索引？
高频查询字段放左边
考虑查询的WHERE、ORDER BY、GROUP BY条件
避免过度索引，通常3-5个字段的联合索引足够


### 事务
事务（Transaction）：一组SQL语句组成的逻辑处理单元，这些操作要么全部成功，要么全部失败回滚。
在MySQL中主要保证数据的一致性，特别是在多用户并发的情况下。

事务四大特性：ACID
1. 原子性（Atomicity）：事务中的所有操作要么全部成功，要么全部失败回滚。
2. 一致性（Consistency）：事务执行前后，数据库的状态保持一致。
3. 隔离性（Isolation）：事务之间相互独立，互不干扰。
4. 持久性（Durability）：事务一旦提交，对数据库的修改是永久的。


**MySQL中默认采用自动提交模式，即每一条SQL语句都会自动作为一个独立的事务提交。**

显示事务控制：
- 显式开启事务：`START TRANSACTION`或`BEGIN`
- 提交事务：`COMMIT`
- 回滚事务：`ROLLBACK`

在MySQL中，只有**InnoDB**支持事务，MyISAM不支持。


### MySQL存储引擎

从MySQL5.7版本开始，InnoDB成为默认的存储引擎，MyISAM逐渐被淘汰。

1. InnoDB存储引擎：
   - 支持事务
   - 支持ACID
   - 支持行级锁
   - 支持外键
   - 支持MVCC（多版本并发控制）
   - 采用聚簇索引存储结构
   - 通过undo log实现事务回滚
   - 通过redo log保证事务持久性

2. MyISAM存储引擎：不支持事务、不支持行级锁（只能锁表）、不支持外键、不支持MVCC。

索引实现：
InnoDB使用`聚簇索引`，主键索引的叶子节点直接存储数据行.
MyISAM使用`非聚簇索引`，索引和数据分离存储。






### 什么是脏读、不可重复读、幻读？
在数据库系统中，事务的并发执行可能会引发多种数据一致性问题，其中最常见的就是脏读(Dirty Read)、不可重复读(Non-repeatable Read)和幻读(Phantom Read)。
1. **脏读（Dirty Read）**：脏读是指一个事务**读取**了另一个事务尚**未提交**的数据修改。如果读取到的数据在另一个事务中随后被**回滚**，那么该数据对当前事务来说就是"脏"的、不可靠的。脏读通常发生在​​读未提交(READ UNCOMMITTED)​​隔离级别下，这是最低的事务隔离级别。
2. **不可重复读（Non-repeatable Read）**：不可重复读是指在一个事务内多次读取同一数据时，**由于其他事务的修改并提交**，导致每次读取到的数据不一致。发生在​​读已提交(READ COMMITTED)​​隔离级别下。
3. **幻读（Phantom Read）**：在同一事务内，多次查询同一范围的数据，结果不一致。这是因为在事务执行过程中，**其他事务对数据进行了新增或删除**，导致第一次查询的数据与第二次查询的数据不一致。

总结：
脏读：读取到未提交的数据（数据未提交，可能回滚）
不可重复读：读取到已提交的数据，但是数据内容发生了变化（数据被其他事务修改），同一数据两次读取不一致。
幻读：读取到已提交的数据，但是数据数量发生了变化（数据增减），同一范围的数据两次查询不一致。

### MySQL事务的隔离级别？默认是什么？
MySQL 支持四种标准的事务隔离级别，按隔离强度从低到高依次为：
1. **读未提交（Read Uncommitted）**：允许读取未提交数据，一致性最差，性能最高。
2. **读已提交（Read Committed）**：仅读取已提交数据，避免脏读，性能较高。
3. **可重复读（Repeatable Read）**：同一事务内多次读取结果一致，**MySQL默认隔离级别**，性能中等。
4. **串行化（Serializable）**：提供严格的事务隔离，完全串行化执行，避免所有并发问题。性能最低。

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
| -------- | ---- | ---------- | ---- |
| ​​READ UNCOMMITTED​​	 读未提交  | 可能 | 可能       | 可能 |
| ​​READ COMMITTED​ 读已提交 | 不可能 | 可能       | 可能 |
| ​​REPEATABLE READ​​	可重复读 | 不可能 | 不可能     | 可能 |
| ​​SERIALIZABLE​ 串行化   | 不可能 | 不可能     | 不可能 |

默认隔离级别：
- MySQL：可重复读（Repeatable Read）
- Oracle：读已提交（Read Committed）


MySQL的可重复读通过MVCC（多版本并发控制）和Gap Lock（间隙锁）机制，在InnoDB存储引擎下基本解决了幻读问题。

### 什么是MVCC？
MySQL的**InnoDB**存储引擎可以在 **可重复读** 隔离级别下解决**幻读**问题：
1. MVCC（多版本并发控制）：通过创建事务开始时的数据快照来避免幻读。
2. 间隙锁：通过锁定查询范围内的记录和间隙来防止其他事务插入新记录。

### MySQL的索引类型
1. **B+树索引**：适用于等值查询和范围查询。
2. **哈希索引**：适用于等值查询。
3. **全文索引**：适用于全文搜索。
4. **空间索引**：适用于地理位置查询。

逻辑分类：
1. 普通索引
2. 唯一索引
3. 主键索引
4. 复合索引
5. 前缀索引

```sql
create index index_name on table_name(column_name);
create unique index ...
create index index_name on table_name(column1,column2);
drop index index_name on table_name;
```

### 索引失效的场景
1. 使用!= 或者 <> 操作符，非等值查询需要扫描大部分数据
2. 对索引列使用函数或表达式
3. 使用OR连接条件
4. 使用LIKE通配符查询
5. 违反最左匹配原则。联合索引(a,b,c)只能按a、(a,b)、(a,b,c)的顺序使用，跳过左侧列会导致索引失效
6. ​​范围查询后的列无法使用索引。在联合索引中，若某一列使用范围查询(>、<、BETWEEN)，其后的列无法使用索引


### 什么是聚簇索引和非聚簇索引
1. 聚簇索引：是一种​​将`数据存储与索引结合​`​的索引类型



2. 非聚簇索引：是一种​​将`索引与数据分开存储​`​的索引类型


### 索引存储结构 B树与B+树

B树：是一种平衡的多路搜索树，具有一下特点：
- 每个节点最多包含m个子节点
- 除根节点和叶子节点外，每个节点至少有⌈m/2⌉个子节点
- 所有叶子节点位于同一层
- 节点中的关键字按非递减顺序排列
- 关键字数量=子节点数-1

```text
        [10, 20]
       /    |    \
[5,8]  [15,18]  [25,30]
```


B+树：是B树的一种变体，具有以下特点：
- 非叶子节点只存储键值（索引信息），不存储数据
- 所有数据都存储在叶子节点中
- 叶子节点通过指针相连形成链表，便于范围查询

```text
        [10, 20]
       /    |    \
[5,8,10]->[15,18,20]->[25,30]
(叶子节点链表连接)
```

B+树的查询稳定，空间利用率较高，相同数据量下B+树更加矮壮，


MySQL InnoDB引擎 使用B+树作为存储结构
- 主键索引（聚簇索引）叶子几点存储完整数据记录
- 二级索引：叶子节点存储主键值


在InnoDB中，主键索引就是聚簇索引，而非主键索引都是非聚簇索引，查询时可能需要回表操作


为什么数据使用B+树？

1. 更适合磁盘I/O
2. 更高效的范围查询
3. 更高的查询稳定性
4. 更高的空间利用率

### MySQL索引建立原则

1. 选择合适的索引列：
    - 高频查询字段为经常出现在WHERE、GROUP BY、ORDER BY或JOIN子句中的字段创建索引，这些字段参与数据筛选和排序的频率高，索引能显著提升查询效率。
    - 不为NULL的字段：索引字段应尽量不为NULL

2. 避免不合理的索引设计：
   - 多个索引包含相同列组合时会产生冗余。例如已有索引(a,b)，再创建索引(a)就是冗余的。
   - 控制索引数量：索引会占用存储空间，并在数据写入时带来额外开销。一般建议单表索引不超过5-7个
   - 避免使用频繁更新的列作为主键


单列索引与复合索引：

- 单列索引​​：适合高频查询的单个字段
- 复合索引(联合索引)​​：当查询经常涉及多个字段组合时，复合索引比多个单列索引更高效
   - 最左前缀原则​​：索引(a,b,c)可支持a、(a,b)、(a,b,c)查询，但无法用于b、c或(b,c)查询。
   - 列顺序策略​​：高频查询列放左侧；等值查询列优先于范围查询列。
   - 长度控制​​：单个复合索引最好不要超过5-7列


- 尽量使用覆盖索引，避免回表操作
- 控制索引数量，避免过多索引影响写入性能
- 复合索引遵循最左匹配原则




### 慢查询定位与优化？

使用`EXPLAIN`命令分析SQL执行计划

关注列：

`type`：ALL(全表扫描)、index、range、ref、eq_ref、const
`key`：实际使用的索引
`rows`：预估扫描行数
`Extra`：Using filesort(需要额外排序)、Using temporary(使用临时表)




