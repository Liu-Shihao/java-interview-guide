
## 数据库索引优化

### 索引类型
按照逻辑分类：唯一索引、普通索引、主键索引、联合索引、全文索引等
按照数据结构可以分为：B树索引、B+树索引、hash索引、位图索引、倒排索引等

全文索引采用​​倒排索引​数据结构：建立"词元→文档位置"的映射关系
Hash索引适合之做等值查询的数据，不支持范围查询和排序
全文索引FullText适合文章、大文本内容，
位图索引：Bitmap，是一种特殊类型的数据库索引结构，使用二进制位图表示数据是否存在，能够提供极高的查询效率，和极小的储存空间占用
为每个不同的索引键创建一个位图，每个二进制位对应表中的一行数据，位图中的每一位0或1表示表中某行是否包含该值。
例如性别列有男女两个值，就会生成两个位图，例如对于5行记录，若"男"的位图是10100，表示第1、3行是男性，其余不是。
适用于列的状态值很少

多状态位图表示：
位图索引结构：
CLERK:   10010  (第1、4行是CLERK)
MANAGER: 01001  (第2、5行是MANAGER)
SALES:   00100  (第3行是SALES)

覆盖索引与联合索引：
覆盖索引​是指**一个索引包含了查询所需的所有数据列**，使得查询可以完全通过索引完成，而无需访问数据表本身。
核心特征：避免了回表查询。查询所需数据可以直接从索引结构中获取，不需要回表访问数据库。减少了IO操作，减少磁盘访问，提高查询效率。
通过将查询涉及的列（如Select、Where等子句中的字段）全部包含在索引结构中。

工作原理：
在传统查询中，数据库通常需要先通过索引找到行指针，在回表获取完整的数据。
而覆盖索引则直接通过索引就能获取所有需要的数据，跳过了回表步骤。

联合索引，也称复合索引，是在多个列上创建的索引结构。一个索引包含多个列，这些列按照特定的顺序排列。
最左匹配原则：查询必须使用索引的最左侧列才能充分利用索引


覆盖索引可以通过联合索引实现，但也可以通过单列索引实现。



### 索引失效场景：
1. 违反最左匹配原则：使用联合索引时未从最左列开始，或者跳过中间列，导致索引失效
2. 对索引列使用函数或运算操作，运算后的值无法直接匹配索引结构
3. Like模糊查询时通配符在前，导致索引失效
4. 使用Or连接，使用不等于或大于小于操作符，都会导致索引失效，全表扫描
5. 隐式类型转换：varchar字段使用了数字比较


使用explain查看执行计划，查看TYPE列，是否使用索引，如果是ALL表示全表扫描

B树一种**多路平衡查找树**，专门为磁盘设计，节点是全局有序的
B+树是B树的一种变体，节点全局有序，范围查询高效，B+树的所有数据都存储在叶子节点，非叶子节点只存储键值和子节点指针，B+树的查询效率更加稳定，每次查询都要走到叶子节点

为什么使用B+树作为索引存储结构？
B-Tree和B+Tree在数据存储位置上有本质区别：B树所有节点都存储数据，而B+树只有叶子节点存储数据，
B-Tree​​：每个节点既存储键值(key)也存储实际数据(data)，数据分布在整棵树的所有层级；
B+Tree​​：只有叶子节点存储完整数据记录，非叶子节点仅存储键值和子节点指针，所有叶子节点通过双向链表连接，形成一个有序的数据序列
这种设计使得B+Tree的非叶子节点可以容纳更多索引项，显著降低了树的高度。对于相同规模的数据，B+Tree通常比B-Tree更"矮胖"，磁盘I/O次数更少
B+Tree所有的叶子节点通过指针形成双向链表，只需对链表扫描，不需要回溯到上层节点，只需遍历叶子节点链表即可获取全部数据。所以B+树查询更加高效
而B-Tree进行范围查询时需要频繁地在不同层级的节点间跳转，效率明显较低


红黑树是一种自平衡的二叉查找树，
全局有序，通过中序遍历红黑树，可以得到所有节点的有序序列
红黑树不适合数据库场景，二叉树结构导致高树太高，磁盘IO次数多

总结：
B树所有节点都存储数据，B+树只有叶子结点存储数据，并且通过双向链表连接，非叶子节点只存储键值和子节点指针。
B+树查询更高效，更稳定，相同数据规模下，B+树更加矮胖，磁盘IO次数更少。

### 最左匹配原则
最左匹配原则的原因是因为B+树索引的物理存储结构
当创建ABC联合索引时，B+树首先按照A字段排序，a相同则按照B字段排序，b相同则按照c字段排序。

所以，只有最左索引A在全局有序，B字段仅在A字段相同时才有序
这种结构决定了必须冲最左列开始查询才能利用索引的有序性，如果跳过A字段或者中间字段，则无法利用索引的有序结构快速定位数据。
查询顺序不是依次按照联合索引字段顺序查询，或者对最左列字段进行范围查询（>、<）都会导致最左匹配失效


### 索引设计原则：
对频繁查询的列创建索引，对where、join、order by、group by 子句中频繁出现的列创建索引
避免对更新频繁的列创建索引，维护索引会带来额外的开销
避免对包含null值过多的列创建索引
对于大文本Blob类型，考虑使用前缀索引或者全文索引替代

创建联合索引时要注意最左匹配原则，将高频查询和高区分度的列放在最左列



### 什么是聚簇索引和非聚簇索引？
聚簇索引是一种将数据存储和索引合为一体的索引方式。
每张表只能有一个聚簇索引，因为数据的存储顺序只能按照一个索引排列，主键默认作为聚簇索引。
在InnoDB存储引擎中，聚簇索引基于B+树实现，B+树结构，叶子节点直接存储数据页

非聚簇索引是一种索引与数据分离的索引方式，索引存储的是数据的位置(指针或主键值)而非数据本身
一张表可以有多个非聚簇索引，查询时需要"回表"操作，即先通过索引找到指针，再访问数据文件

聚簇索引和非聚簇索引都可以通过B+树索引实现：
B+树：
叶子节点：存储完整的键值和对应的数据记录
非叶子节点：存储键值和子节点指针

聚簇索引：叶子节点直接存储行数据（索引和数据一体）
非聚簇索引：叶子节点存储键值和主键（索引与数据分离）

B+树的基本概念​​确实规定所有数据存储在叶子节点，但这是​​逻辑层面的设计​​。是否索引与数据一体存储​​取决于具体实现

回表流程：
1. 定位叶子节点，获取索引列值和对应的主键值
2. 使用获得的主键值，在聚簇索引中查找，聚簇索引的叶子节点包含完整的数据行
3. 从聚簇索引叶子节点读取完整数据行，返回给查询引擎

总结，非聚簇索引需要回表查询，首先定位叶子节点，获得索引位置和主键值，在通过主键聚簇索引查询到叶子节点，获取所有数据行信息。

### 慢查询排查
1. 开启慢查询日志 SET GLOBAL slow_query_log = 'ON'
2. 分析慢查询原因，使用EXPLAIN执行计划分析，关键字段解读：
   type：访问类型，性能排序：system > const > eq_ref > ref > range > index > ALL
   key：实际使用的索引，NULL表示未使用索引查询



### MySQL Log
1. error log:记录MySQL服务器启动、运行和停止过程中的错误信息
2. binlog:记录所有更改数据的SQL语句(DDL和DML),用于主从复制(Replication),记录的不是简单的SQL文本，而是事件(Events)
3. query log:记录所有到达MySQL服务器的SQL语句,对性能有影响，通常只在调试时开启
4. slow query log:记录执行时间超过指定阈值的SQL语句,用于发现和优化性能瓶颈,可记录未使用索引的查询
5. redo log :确保事务的持久性,用于崩溃恢复
6. undo log:记录事务发生前的数据状态,用于事务回滚,实现MVCC(多版本并发控制)


## MYSQL事务
MySQL InnoDB引擎支持事务，支持行锁
MySQL MyISAM不支持事务，不支持行锁，是表级锁，不支持外键
Oracle 使用单一的OBT（​Oracle Database Block Organized Table）存储引擎，支持事务
事务特性 ACID：
原子性：一组事务，要么全部成功，要么全部失败，MySQL通过undo日志进行回滚，实现原子性，记录事务未提交前的状态，失败时回滚。
一致性：事务执行前后，数据库必须冲一个一致性状态，转换到另一个一致性状态。例如转账前后两个账户的金额应该保持不变。
隔离性：事务之间相互隔离，互不影响。MySQL通过MVCC（多版本并发控制）和锁机制实现，有四种隔离级别。
持久性：事务一旦移交，对数据的改变是永久的。即使数据库崩溃，MySQL可以通过redo日志重新恢复数据。

MySQL默认自动提交每条SQL语句。

脏读（读未提交）：一个事务可能读取另一个事务未提交的数据，造成脏读（另一个数据可能回滚）。
不可重复读：同一事务内多次读取同一个数据结果不同。
幻读：同一事物内多次查询结果集行数不同。

四种事务隔离级别：
read uncommited 读未提交  可能脏读、不可重读读和幻读， 
read commited   读已提交  避免脏读，可能出现不可重读读和幻读，Oracle默认的隔离级别。
repeatable read 可重复读  避免脏读和不可重复读，可能幻读，    MySQL默认的隔离级别
serializable    串行化    避免脏读、不可重复读和幻读，避免所有问题，但是性能最低

MVCC 多版本并发控制：
共享锁：允许并发读取
排它锁：阻止其他事务读写
间隙锁（gap lock）:防止幻读
临建锁：记录锁+间隙锁组合





# SQL 基础
- DML（数据操纵语言）：SELECT、INSERT、UPDATE、DELETE语句
- DDL（数据定义语言）：CREATE、ALTER、DROP语句
- DCL（数据控制语言）：GRANT、REVOKE语句
- 高级查询：GROUP BY、HAVING、ORDER BY、LIMIT等分组排序操作
- 聚合函数：COUNT、SUM、AVG、MAX、MIN等常用函数

## DDL数据定义语言
```sql
-- 创建数据库
CREATE DATABASE mydb;
-- 删除数据库
DROP DATABASE mydb;
-- 使用数据库
USE mydb;
-- 创建表
CREATE TABLE employee (
    emp_id INT PRIMARY KEY,
    emp_name VARCHAR(50) NOT NULL,
    hire_date DATE,
    age INT,
    salary DECIMAL(10,2)
)
-- 添加新列
ALTER TABLE employee ADD COLUMN department VARCHAR(30);

-- 删除现有列
ALTER TABLE employee DROP COLUMN department;

-- 修改列的数据类型
ALTER TABLE employees MODIFY COLUMN age FLOAT;

-- 重命名列
ALTER TABLE employees RENAME COLUMN age TO employee_age;

-- 添加主键约束
ALTER TABLE 表名 ADD PRIMARY KEY (列名);

-- 添加外键约束
ALTER TABLE 表名 ADD FOREIGN KEY (列名) REFERENCES 另一个表名(列名);

-- 删除约束
ALTER TABLE 表名 DROP CONSTRAINT 约束名;

```

## DQL 数据查询语言
```sql
-- 基本查询
SELECT emp_name, salary FROM employee;

-- 条件查询
SELECT * FROM employee WHERE salary > 5000;

-- 模糊查询
SELECT * FROM employee WHERE emp_name LIKE '张%';

-- 排序
SELECT * FROM employee ORDER BY salary DESC;

SELECT * FROM employee WHERE salary > 5000 

-- 分组统计
SELECT department, AVG(salary) as avg_salary 
FROM employee 
GROUP BY department 
HAVING AVG(salary) > 6000;

```

## FROM、JOIN、WHERE、GROUP BY、HAVING、SELECT、ORDER BY、LIMIT的执行步骤
1. FROM/JOIN: 从指定的表或视图中获取数据。
2. WHERE: 根据指定的条件过滤数据。
3. GROUP BY: 根据指定的列对数据进行分组。
4. HAVING: 对分组后的数据进行过滤。
5. SELECT: 从数据集中选择需要的列。
6. ORDER BY: 根据指定的列对数据进行排序。
7. LIMIT: 限制返回结果的数量。

举例：

```sql
SELECT u.region, SUM(o.amount) AS total_amount
FROM users u
JOIN orders o ON u.user_id = o.user_id
WHERE o.create_time BETWEEN '2025-01-01' AND '2025-12-31'
GROUP BY u.region
HAVING SUM(o.amount) > 10000
ORDER BY total_amount DESC
LIMIT 10;
```


## DML 数据操纵语言
```sql
-- 插入数据
INSERT INTO employee (emp_id, emp_name, hire_date, age, salary) 
VALUES (1001, '张三', '2022-01-01', 25, 5000);

-- 更新数据
UPDATE employee SET salary = 6000 WHERE emp_id = 1001;

-- 删除数据
DELETE FROM employee WHERE emp_id = 1001;
```

## DCL 数据控制语言
```sql
-- 授权
GRANT SELECT, INSERT ON employee TO user1;

-- 撤销权限
REVOKE INSERT ON employee FROM user1;
```




# 数据库的三范式是什么？
1. 第一范式：**字段不可再分**
    - 表中的每一个字段都是原子性的，不可再分，即每一个字段只能存储一个值。
    - 目的是为了消除重复字段和多值字段，让数据结构更规范。
2. 第二范式：**消除部分依赖**
    - 在第一范式的基础上，非主键字段完全依赖主键，不能产生部分依赖。
      举例：不符合2NF（复合主键为 课程号 + 学号）
        | 课程号  | 学号   | 学生姓名 | 成绩 |
        | ---- | ---- | ---- | -- |
        | C001 | S001 | 张三   | 90 |
      
      这里学生姓名只依赖于学号，而不是完整的主键（课程号 + 学号）。
      应该拆成两个表：
        学生表：
        | 学号   | 学生姓名 |
        | ---- | ---- |
        | S001 | 张三   |
        
        成绩表：
        | 课程号  | 学号   | 成绩 |
        | ---- | ---- | -- |
        | C001 | S001 | 90 |

3. 第三范式：**消除传递依赖**
    - 在第二范式的基础上，任何非主键字段不能依赖于其他非主键字段。
    举例：不符合3NF
        | 学号   | 姓名 | 班级ID | 班级名称  |
        | ---- | -- | ---- | ----- |
        | S001 | 张三 | B01  | 一年级一班 |

       班级名称 依赖于 班级ID，而 班级ID 又依赖于 学号（主键）。这是一种传递依赖。
       应拆成：学生表和班级表
        | 学号   | 姓名 | 班级ID |
        | ---- | -- | ---- |
        | S001 | 张三 | B01  |

        | 班级ID | 班级名称  |
        | ---- | ----- |
        | B01  | 一年级一班 |

---
总结
| 范式  | 核心要求        | 主要目的是      |
| --- | ----------- | ---------- |
| 1NF | 字段原子性       | 避免重复与多值字段  |
| 2NF | 非主属性完全依赖主键  | 避免部分依赖     |
| 3NF | 非主属性不传递依赖主键 | 避免传递依赖，去冗余 |

但是在实际项目中，我们会在范式与性能之间做权衡，视业务场景进行适当反范式设计。

# 数据库事务与锁机制
- ACID：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）
- 事务隔离级别：读未提交（Read Uncommitted）、读已提交（Read Committed）、可重复读（Repeatable Read）、串行化（Serializable）
- 锁机制：行锁、表锁、间隙锁、临键锁



## 索引的存储结构
索引的主要数据结构：
- B-Tree
- B+Tree(MySQL主要使用的结构)
- Hash哈希索引
- Full-text全文索引

### B-Tree B树
B树是多路平衡查找树
- 所有叶子节点位于同一层，
- 每个节点包含`键值`和`指向数据的指针`。

### B+Tree B+树
B+树是在B树的基础上进行优化的一种数据结构。
- `非叶子`节点只存储`键值`，**不存储数据**
- `叶子`节点存储所有**键值**和**数据指针**
- `叶子`**节点通过指针连接形成链表**

InnoDb默认使用B+Tree索引


聚簇索引(Clustered Index)和非聚簇索引(Non-Clustered Index)是数据库中两种重要的索引类型，它们在数据存储方式和查询性能上有显著差异
聚簇索引：是一种​​将数据存储与索引结合​​的索引类型，叶子节点包含整行数据。​

在InnoDB中，​主键索引是聚簇索引​​，直接存储数据，其他索引都是非聚簇索引​​，需要回表查询。




# 数据库性能优化
## 索引优化

- 索引类型：B+树索引结构原理、聚簇索引与非聚簇索引的区别
- 索引设计：组合索引的最左前缀原则、覆盖索引、索引选择性计算
- 索引失效场景：函数操作、类型转换、LIKE模糊查询等导致索引失效的情况
- 索引优缺点


## 最左匹配原则？为什么是最左匹配
最左匹配原则是指在使用联合索引(复合索引)时，MySQL会从索引的最左边字段开始向右匹配，只有查询条件中包含了联合索引的第一个字段(最左字段)，索引才会被使用。如果查询条件不包含最左字段，索引将失效。

为什么是从最坐匹配？
这与索引的底层数据结构(B+树)和存储方式直接相关：
1. B+树索引的排列方式，联合索引在B+树中的存储结构是：先按第一个字段排序，第一个字段相同的情况下，按第二个字段排序
2. B+树索引使用二分查找，必须有序才能高效查找。如果不从最左字段开始，后续字段在索引中是无序的

如何设计高效的联合索引？
高频查询字段放左边
考虑查询的WHERE、ORDER BY、GROUP BY条件
避免过度索引，通常3-5个字段的联合索引足够





