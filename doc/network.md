


## 网络分层模型

网络分层模型是一种将网络通信过程分为多个层次的模型，每个层次负责不同的功能。常见的网络分层模型有OSI七层模型和TCP/IP四层模型。

### OSI七层模型

OSI七层模型是一种将网络通信过程分为七个层次的模型，每个层次负责不同的功能。OSI七层模型包括
1. 物理层：传输原始比特流（0和1），定义电气、机械和功能规范
协议/设备：以太网、光纤、双绞线、集线器（Hub）。数据单位：比特（Bit）
2. 数据链路层：将比特组合成帧，提供节点到节点的传输，错误检测
协议/设备：PPP、MAC子层、以太网协议、交换机（Switch）。数据单位：帧（Frame）
3. 网络层：路由选择、IP寻址、分组转发
协议/设备：IP、ICMP、ARP、路由器（Router）。数据单位：数据包（Packet）
4. 传输层：端到端连接控制，流量控制，错误恢复
协议：TCP，UDP
5. 会话层：建立、管理和终止会话
协议：RPC
6. 表示层:功能：数据格式转换、加密解密、压缩解压缩
协议：SSL/TLS
7. 应用层：为用户应用程序提供网络服务接口
HTTP
FTP
SMTP
DNS

### TCP/IP四层模型
TCP/IP模型是互联网实际使用的协议栈，分为4层：

1. 网络接口层： 对应OSI的：物理层 + 数据链路层。处理物理连接和硬件细节。设备：网卡、交换机
2. 网际层：对应OSI的：网络层。功能：路由、寻址、分组转发。设备：路由器
3. 传输层：对应OSI的：传输层。端到端通信，可靠性保证。协议：TCP、UDP
4. 应用层：对应OSI的：会话层 + 表示层 + 应用层。提供各种网络应用服务。协议：HTTP、FTP、DNS、SMTP




## TCP和UDP协议的区别是什么？各自的应用场景
TCP（传输控制协议）面向连接的协议，需要三次握手建立连接，可靠传输，保证数据顺序到达。传输效率较低，因为需要建立连接和保证可靠性。双全工通信。适用可靠性传输的应用。
例如：
- 网页浏览（HTTP/HTTPS）需要可靠传输网页内容。
- 文件传输（FTP/SFTP），确保文件完整无误的传输。
- 电子邮件（SMTP）需要可靠传输邮件，保证邮件内容不丢失不重复。
- 远程登录（SSH）确保命令和响应的准确传输。

UDP（用户数据报协议），无连接的协议，不可靠传输，不保证送达，不保证顺序。传输效率较高，支持一对一，一对多，多对多通信。适合实时性要求高，能容忍少量丢失的应用。
例如：
- 实时音视频传输：实时性要求高，能容忍少量丢包，Zoom、微信视频通话
- 在线游戏：需要快速传输游戏状态更新。
- DNS查询：简单查询/响应模型，快速解析
- 直播流媒体：优先保证实时性而非可靠性
- 广播/多播应用：一对多传输场景。TPTV、网络时钟同步

---
总结：
TCP（传输控制协议）面向连接，保证可靠性，但是效率较低。使用场景：网页浏览，文件传输、邮件发送等
UDP（用户数据报协议）无连接，不可靠，但是高效。使用场景：实时音视频传输、在线游戏、DNS查询、直播流媒体、广播/多播应用。



## 三次握手与四次挥手的过程是怎样的？为什么需要三次握手？
三次握手 建立连接
 1. SYN 同步，客户端发送SYN=1 请求建立连接，并随机生成一个初始化序列号 seq=x
 2. SYN-ACK 同步确认，服务端收到SYN后，返回SYN=1 和 ACK=1 确认，并发送自己的初始序列号 seq=y，同时期望客户端的确认号 ack=x+1
 3. ACK 确认，客户端收到SYN-ACK后，返回ACK=1 确认，并发送自己的确认号 ack=y+1，并可以开始发送数据
 服务端收到ACK后，建立连接，双方进入ESTABLISHED状态，开始传输数据。



为什么需要三次握手？
- 防止历史连接请求干扰，如果客户端发送的 SYN 因网络延迟而滞留，服务端可能误认为新的连接请求。
- 确保双方收发能力正常：两次握手只能确认客户端的发送能力和服务端的接收能力，但无法确认服务端的发送能力和客户端的接收能力。
- 避免资源浪费：如果只有两次握手，服务端可能因未收到 ACK 而一直等待，浪费资源。


四次挥手：确保双方都能安全关闭连接
1. FIN：客户端发送FIN=1请求关闭连接。  
2. ACK：服务端收到FIN，返回ACK=1，可能任有数据要发送。 
3. FIN：服务端发送FIN=1。  
4. ACK：客户端确认，客户端收到FIN后发送ACK，服务端收到ACK之后连接关闭。 


TCP是双全工的，双方可以独立关闭连接
服务端可能仍有数据要发送，所以先 ACK 确认，再发送 FIN 关闭。

---
总结：

三次握手：
客户端首先发送SYN给服务端，服务端收到SYN后返回 SYN + ACK给客户端，客户端收到ACK后，在返回ACK给服务端，双方建立连接。

四次挥手
客户端首先发送FIN给服务端，服务端收到FIN后，返回ACK给客户端，此时服务端仍有可能发送数据，等服务端数据处理完成之后，服务端在发送FIN给客户端，客户端收到FIN之后又，返回ACK给服务端，连接关闭。


三次握手和四次挥手是 TCP 协议的特性，不是 HTTP 独有的。
HTTP 是基于 TCP 的应用层协议，连接建立和关闭依赖 TCP 的机制。

### TCP/IP协议族包含哪些协议？
- TCP  可靠传输，  传输层
- UDP  无连接，不可靠但高效，  传输层
- IP   网络层寻址和路由  ， 网络层
- ICMP  网络控制消息，如ping  网络层
- ARP   IP地址 -> MAC地址解析  ， 数据链路层
- HTTP/HTTPS  超文本传输协议， 应用层
- FTP 文件传输， 应用层
- SSH  安全远程登录 ， 应用层
- DNS  域名解析，应用层


## HTTP和HTTPS的区别是什么？HTTPS是如何保证安全的？
HTTP是基于TCP的明文传输协议，HTTPS是在HTTP协议的基础上增加了SSL/TLS加密传输，通过证书认证服务器身份，确保数据的安全性。
HTTP默认端口是80，HTTPS默认端口是443
HTTPS需要CA办法的SSL证书，HTTP不需要

SSL/TLS加密层
HTTPS = HTTP + SSL/TLS，在传输层和应用层之间增加安全层

混合加密机制
非对称加密：使用公钥加密，私钥解密，如RSA算法
对称加密：使用相同的密钥加密和解密，如AES算法


## Java NIO和传统IO在网络编程中的区别？Selector的作用是什么？
传统IO（BIO）阻塞IO，面向流（Stream），线程模型是1：1，连接数多时开销大。
文件操作：InputStream/OutputStream
网络操作：SocketInputStream/SocketOutputStream
无论是读取文件还是网络数据，都会阻塞线程。

NIO面向缓冲区Buffer，是非阻塞IO线程模型是1：N，一个线程可以处理多个连接。适合高并发场景。核心组件是Channel/Buffer/Selector。


NIO的三大核心组件：
Channel 通道：全双工通信，可同时读写。类型：FileChannel、SocketChannel，ServerSockerChannel

Buffer 缓冲区：数据读写的中转站。

Selector 选择器：多路复用器的核心组件，可以监听多个Channel的IO事件，事件类型：OP_READ、OP_WRITE、OP_CONNECT、OP_ACCEPT。
核心方法：select()阻塞等待事件，返回已就绪的Channel集合。


Selector的核心作用：
1. 多路复用机制：单个线程管理多个Channel，通过一个Selector线程监控所有注册的Channel。
2. 事件驱动模型：只有Channel发送IO事件时才会处理，避免空轮询。

减少线程开销；
提高吞吐量；
避免上下文切换；

## Java中如何实现非阻塞IO？
在Java中实现非阻塞I/O主要依赖于Java NIO（New I/O）包中的核心组件。

核心组件：
- Channel 通道：全双工通信，可同时读写。
   - SocketChannel：TCP网络通信
   - ServerSocketChannel：服务端监听连接
- Buffer 缓冲区：数据读写的中转站。
   - ByteBuffer：最常用的缓冲区
   - CharBuffer、IntBuffer等：特定类型缓冲区
- Selector 选择器：多路复用器的核心组件，可以监听多个Channel的IO事件。

实现非阻塞IO的基本流程：
1. 打开Channel，配置为非阻塞模式。
2. 注册到Selector，监听感兴趣的事件，如OP_READ、OP_WRITE。
3. 循环调用Selector的select()方法，阻塞等待就绪事件。
4. 事件就绪后，调用Selector的selectedKeys()方法获取就绪Channel集合。
5. 遍历就绪Channel集合，进行读写操作。

## Tomcat
Tomcat作为广泛使用的Java Web服务器，其I/O模型设计经历了多次演进：
在Tomcat7之前默认使用BIO，即阻塞IO，典型“一个请求一个线程”模型。
在Tomcat8以后，默认使用NIO，基于Java NIO的多路复用实现，提升了并发处理能力。
在Tomcat9以后，引入了异步非阻塞IO（AIO），进一步优化了性能。

NIO模型在Tomcat中的具体实现：
核心组件： 
- Poller线程：通过Selector监控所有连接的就绪事件。
- Worker线程池：处理实际的业务请求。

1. 客户端请求
2. NIO Acceptor 接收连接，注册到Poller的Selector
3. Poller检测就绪事件
4. NIO Worker 处理业务请求

## HTTP常见状态码有哪些？分别代表什么含义？
- 200 请求成功
- 201 请求成功，Created 并且服务器成功创建了新资源，常用于POST请求
- 202 请求接受，但是尚未处理完成，异步处理
- 204 请求成功，但是响应中没有内容，常用于DELETE请求

3xx（重定向状态码）
- 301 重定向，资源已永久移动到新位置，浏览器会自动跳转
- 302 重定向，资源临时移动到新位置，浏览器会自动跳转
- 303 重定向，请求的资源已被永久移动到新位置，客户端应当使用新的URL重新发起请求
- 304 资源未修改，浏览器会从缓存中获取

4xx（客户端错误状态码）
- 400 Bad Request 请求参数错误
- 401 Unauthorized 需要身份验证（未提供或认证失败）
- 403 Forbidden 禁止访问，服务器理解请求客户端的请求，但是拒绝执行此请求（无权限访问）
- 404 Not Found 资源不存在
- 405 Method Not Allowed 请求方法不被允许
- 406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求
- 408 Request Timeout 请求超时
- 413 Request Entity Too Large 请求实体过大，服务器无法处理
- 414 Request-URI Too Long 请求的URI过长（超过服务器的限制）
- 415 Unsupported Media Type 不支持的媒体类型
- 429 Too Many Requests 客户端发送请求过多，服务器拒绝处理

5xx（服务器错误状态码）
- 500 Internal Server Error 服务器内部错误
- 502 Bad Gateway 网关错误
- 503 Service Unavailable 服务不可用，服务器暂时过载或维护，例如超过Tomcat最大连接数
- 504 Gateway Timeout 网关超时，服务器作为网关或代理，未及时从上游服务器收到请求
- 505 HTTP Version Not Supported HTTP版本不支持

---
常见状态码记忆技巧
成功类：记住200 OK是最常见的成功响应

重定向类：
永久移动301
临时移动302
不修改304

客户端错误：
错误请求400
未授权401
禁止访问403
找不到404

服务端错误：
服务器错误500
服务不可用503

## HTTP请求方法有哪些？GET和POST的区别？
- GET   获取服务器资源
- POST  想服务区提交数据，服务器成功创建资源返回201状态码
- PUT   替换目标资源， 用于更新数据
- DELETE 删除指定资源，返回204状态码

GET请求目的是为了获取资源（读操作），通过URL传递参数，参数明文显示在URL中，参数长度有限制，一般为2kb，参数安全性低。GET请求会被缓存。

POST请求目的是向服务器提交数据（写操作），参数包含在请求体中，参数长度没有限制，参数安全性高。


## 什么是RESTful API？它的设计原则是什么？
RESTful API（Representational State Transfer）是一种基于HTTP协议的架构风格，而非标准。


## Cookie和Session的区别是什么？Java中如何实现Session管理？

Cookie存储在客户端浏览器，安全性较低，可以直接查看和篡改。只支持字符串，最大4KB，客户端每次请求自动携带。

Session数据存储在服务器，安全性较高。

可以使用JWT认证代替传统的Session管理，JWT包含用户信息和签名，服务器验证签名即可知道请求是否合法。
JWT包含三部分内容：
- Header 头部：包含JWT的元数据，说明令牌类型和签名算法（如HS256、RS256等）
- Payload 载荷：携带实际数据，包含签发者、接收方、用户信息、过期时间、签发时间、失效时间等
- Signature 签名：验证消息完整性，防止篡改。使用Header和Payload以及密钥生成的签名，用于验证JWT的完整性


## 什么是跨域问题？如何解决跨域问题？
跨域问题（Cross-Origin Resource Sharing，CORS）是由浏览器的同源策略（Same-Origin Policy）引起的安全限制。当网页尝试访问与其不同源的资源时，浏览器会阻止该请求，除非服务器明确允许。

同源判定标准
两个URL在以下三者完全相同时才属于同源：
- 协议（http/https）
- 域名（包括子域名）
- 端口号（默认80/443可省略）

服务端可以设置CORS响应头，允许指定的域名访问资源。

```java
// Spring Boot示例
@Configuration
public class CorsConfig implements WebMvcConfigurer {
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins("https://client.com") // 允许的源
                .allowedMethods("GET", "POST", "PUT") // 允许的方法
                .allowedHeaders("*")                  // 允许的头部
                .allowCredentials(true)               // 允许凭证
                .maxAge(3600);                        // 预检请求缓存时间
    }
}
```

## 什么是WebSocket？与HTTP相比有什么优势？
WebSocket是一种全双工通信协议，它在单个TCP连接上提供双向实时数据传输能力，由HTML5规范引入。与HTTP的"请求-响应"模式不同，WebSocket建立连接后，服务器可以主动向客户端推送数据。
适合场景：
多人聊天应用
多人在线游戏，实时状态同步
金融行情推送

HTTP是半双工，客户端发起请求，服务器相应，短链接，默认无状态。

断开重连：
1. 双端维护心跳机制检测连接健康
2. 客户端携带上一次的会话凭证重新发起连接
3. 服务端维护消息队列或事件日志
4. 重新连接之后请求丢失时间段的数据。

## 什么是反向代理和正向代理？Nginx属于哪种？
正向代理是代理客户端，隐藏客户端身份
反向代理是代理服务端。可以实现负载均衡
Nginx属于反向代理。负载均衡，支持轮询，权重，哈希等算法。可以缓存静态资源，减少服务器负载。


## 负载均衡有哪些常见算法？如何实现？
1. 轮询：按顺序将请求分配给每个服务器
2. 加权轮询：按预设权重分配请求，性能高的服务器获得更多流量
3. 最少连接：将请求分配给当前连接数最少的服务器	
4. IP哈希：根据客户端IP计算哈希值固定分配到某台服务器
5. 随机：完全随机分配请求

## 什么是CDN？它的工作原理是什么？
CDN（Content Delivery Network）内容分发网络，通过将内容分发到全球各地的边缘节点，使用户可以就近获取所需内容，显著提升访问速度和稳定性。

比如：静态内容加速：缓存图片/CSS/JS等不变资源，网站静态资源

传统访问依赖用户到源站的网络质量，而通过CDN加速就近访问，延迟降低50%以上。



## RPC协议
RPC（Remote Procedure Call）协议是一种远程过程调用协议，它允许一台计算机上的程序调用另一台计算机上的程序，就像调用本地程序一样。而无需开发者显式处理网络通信细节。

核心组成
- 服务发现：客户端需要知道服务端地址，RPC框架提供服务注册与发现机制
- 序列化：客户端和服务端需要使用相同的协议对数据进行编码与解码，如Protobuf、Thrift、Avro等
- 网络传输：使用TCP/UDP协议在客户端和服务端之间传输数据
- 客户端 Stub：为客户端生成的代理类，负责处理请求和响应，如gRPC的stub
- 服务端 Stub：为服务端生成的骨架类，负责接收请求和处理业务逻辑，如gRPC的skeleton

典型的RPC协议：
- gRPC，基于HTTP/2，基于protobuf序列化，支持双向流和单向流，基于HTTP/2多路复用，支持长连接，支持双向流和单向流
- Thrift，基于二进制协议，支持单向流，基于HTTP长连接，支持双向流
- Dubbo，基于Java RPC框架，基于Netty网络库，支持多种序列化协议，支持异步调用，支持多种负载均衡策略
- JSON-RPC，基于HTTP，基于JSON序列化，支持单向流，基于HTTP长连接，支持双向流


RPC优势：
二进制编码，Protobuf/Thrift等二进制协议比JSON体积小60%-80%
强类型约束
实时数据流处理，支持双向流式通信。
跨语言支持，Java/Python/Go等语言都有对应的RPC库

## 如何设计一个高并发的网络服务？
1. 设计层面
前端负载均衡层，使用Nginx
后端服务使用微服务架构拆分功能模块，避免单点瓶颈
服务无状态化，可以使用k8s hpa 动态扩容
对数据进行缓存，提高接口查询速度，减小数据库查询压力
使用MQ异步解耦，削峰填谷
使用CDN加速，静态资源就近分发

2. 熔断与降级
服务熔断机制，当服务出现异常时，及时熔断，避免影响其他服务。如Hystrix或Sentinel
服务限流，避免流量过大导致服务崩溃。令牌桶、漏桶算法
服务降级，当服务熔断后，返回默认值或错误信息，而不是直接崩溃。

3. 监控与告警
监控服务端关键指标，如CPU、内存、网络、磁盘等。如Prometheus+Grafana
监控客户端指标，如请求延迟、错误率等。如Jaeger

## 如何保证微服务间的安全通信？

1. 双向mTLS认证，每个服务持有唯一证书，服务通信前相互验证证书，证书定期轮换
2. JWT/OAuth2 认证，服务端颁发JWT令牌，客户端携带令牌访问服务