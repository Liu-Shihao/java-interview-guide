# JVM 虚拟机

JVM（Java Virtual Machine，Java虚拟机）是Java平台的核心组件，负责执行**字节码(.class)文件**

- 跨平台特性：JVM实现了一次编译，到处运行的能力，Java文件编译成字节码文件后可以在任何安装了JVM的系统上运行
- 内存管理：JVM负责内存分配和回收，Java程序可以自动管理内存，无需手动释放内存

## JVM架构
JVM主要由以下子系统组成：
1. 类加载器（Class Loader）：加载.class文件、链接（验证、准备、解析）、初始化类
2. 运行时数据区（Runtime Data Area）：包括方法区、堆、Java栈、本地方法栈、程序计数器
3. 执行引擎（Execution Engine）：解释器、JIT编译器、垃圾回收器
4. 本地接口（Native Interface）：与底层操作系统交互

工作流程：
1. Java源代码编译成字节码文件
2. 类加载器加载字节码文件，链接和初始化类
3. 运行时数据区分配内存
4. 执行引擎解释或编译字节码，执行程序
5. 垃圾回收器回收不再使用的内存


主要的JVM实现：
- HotSpot：Oracle官方JVM实现，广泛应用于生产环境
- J9：IBM J9 JVM，广泛用于IBM的Java产品
- Android Runtime：Android操作系统的JVM实现
- GraalVM：Oracle的JVM实现，支持多种语言，包括Java、JavaScript、Ruby等


## 类加载机制
JVM（Java虚拟机）的​​类加载机制​​是Java运行时的核心机制之一，它负责将类的字节码（.class文件）**加载**到内存中，并进行**验证**、**准备**、**解析**和**初始化**等操作，最终形成可以被JVM直接使用的Java类型。类加载机制是Java实现​​动态性​​（如热部署、动态代理等）的基础。

### 类加载过程
类加载过程分为五个阶段：
1. `加载（Loading）`：加载由`类加载器（ClassLoader）`完成，通过类的**全限定名**（包名+类名），将类的字节码文件加载到内存中，在方法区（Method Area）存储类的元数据，并在堆（Heap）中生成对应的Class对象（作为访问方法区数据的入口）。
2. `验证（Verification）`：验证字节码文件的正确性，防止恶意代码破坏JVM。验证内容​​：
    - 文件格式验证​​：检查.class文件是否符合JVM规范（如魔数0xCAFEBABE）。
    - 元数据验证​​：检查类的继承关系、方法重载等是否符合Java语法（如类是否有父类、是否继承了final类等）。
    - 字节码验证​​：检查指令是否合法（如类型转换是否正确、跳转指令是否正确等）。
    - 符号引用验证​​：检查类对其他类、方法、字段的引用是否正确（在解析阶段进行）。
3. `准备（Preparation）`：为类的静态变量分配内存，并设置默认初始值。

4. `解析（Resolution）`：将常量池中的符号引用转换为直接引用。包括类、接口、字段、方法、接口方法解析。
    - 符号引用：类的全限定名、方法名等字符串形式的引用（如java.lang.String）。
    - 直接引用：内存地址或偏移量（如指向方法区的指针）。
5. `初始化（Initialization）`：为类的静态变量赋予正确的初始值。执行类的静态代码块（static{}）和静态变量的赋值操作（代码中的赋值）。
初始化的时机：
    1. new关键字创建一个实例
    2. 访问类的静态变量或静态方法（非final常量）
    3. 反射调用（如Class.forName("com.example.Test")）
    4. 主类（包含main()方法的类）会被初始化
    5. 子类初始化时，父类必须先初始化。

    初始化顺序：
    1. 父类静态变量、静态代码块
    2. 子类静态变量、静态代码块
    3. 父类实例变量、实例代码块
    4. 父类构造函数
    5. 子类实例变量、实例代码块
    6. 子类构造函数
6. 类卸载（UnLoading）
条件：
    1. 类的所有实例都已被回收
    2. 加载该类的ClassLoader已被GC回收。
    3. 该类的Class对象没有被任何地方引用。
    
    卸载过程：JVM的垃圾回收器（GC）会回收方法区中的类元数据。




### 类加载器
加载（Loader）由​`​类加载器（ClassLoader）`​​完成，JVM提供了3种默认的类加载器：
1. 启动类加载器（Bootstrap ClassLoader）：加载JAVA_HOME/lib下的核心类（如java.lang.*）。
2. 扩展类加载器（Extension ClassLoader）：加载JAVA_HOME/lib/ext下的扩展类。
3. 应用程序类加载器（Application ClassLoader）：加载用户程序的类（classpath下的类）。
4. 自定义类加载器：用户可以自定义类加载器，用于加载自定义的类。

```
Bootstrap ClassLoader（根）
       ↑
Extension ClassLoader（父）
       ↑
Application ClassLoader（子）
```


### 双亲委派模型(Parent Delegation Model)
类加载器采用​​双亲委派机制​​：
- 当一个类加载器收到加载请求时，它首先委托给父类加载器去加载。
- 只有当父类加载器无法加载时，子类加载器才会尝试加载。


为什么采用双亲委派模型？​
1. **​​保证核心类的安全**​​：防止用户自定义的类（如java.lang.String）替换JVM核心类，避免破坏JVM稳定性。
2. ​**​避免类的重复加载​**​：如果父类加载器已经加载了某个类，子类加载器就不会再加载，避免同一个类被多次加载到内存中。
3. ​**​保证类的唯一性​**​：由于类是由​​加载它的类加载器+类全限定名​​共同决定的，双亲委派模型确保了核心类只会被Bootstrap ClassLoader加载一次，避免不同类加载器加载同一个类导致冲突。

在某些特殊情况下，可能需要​​打破双亲委派模型​​，例如：
**​​Tomcat的Web应用类加载器**​​：每个Web应用有自己的WebAppClassLoader，它优先加载自己的类，而不是委托给父类加载器，避免不同Web应用的类冲突。


## JVM内存区域划分

```
JVM内存区域
├── 线程私有
│   ├── 程序计数器
│   ├── Java虚拟机栈
│   └── 本地方法栈
├── 线程共享
│   ├── Java堆
│   │   ├── 新生代
│   │   │   ├── Eden区
│   │   │   └── Survivor区(From/To)
│   │   └── 老年代
│   ├── 方法区(元空间)
│   └── 运行时常量池
└── 直接内存(堆外内存)
```

JVM 内存区域是Java程序运行时数据存储的核心部分，主要分为**线程私有**和**线程共享**两大类。
- 程序计数器 Program Counter Register 
- Java虚拟机栈 VM Stack
- 本地方法栈 Native Method Stack
- 堆 Heap
- 方法区 Method Area
- 运行时常量池 
- 直接内存（Direct Memory）

### 1.程序计数器(Program Counter Register)
程序计数器是一块较小的内存空间，用于记录当前线程执行的字节码指令地址。
- 作用：记录程序执行的位置，用于线程切换后恢复执行位置
- 特点：
   - 线程私有，每个线程都有自己的程序计数器，生命周期与线程相同
   - 唯一不会出现OOM的内存区域
   - 执行Java方法时记录虚拟机字节码指令地址
   - 执行Native方法时为空（Undefined）

### 2.Java虚拟机栈（VM Stack）

作用：用来执行Java方法，存储方法调用的栈帧（Stack Frame）。
每当方法调用时，会在栈中压入一个 **「栈帧」**。
方法执行结束后，该栈帧被弹出。
```
调用方法 main()
 └── 调用方法 A()
      └── 调用方法 B()
           └── 执行完毕，从栈中弹出 B()
      └── 执行完 A()，弹出
 └── 执行完 main()，弹出

```

栈帧（Stack Frame）：每个方法在执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法返回地址等信息

组成：
- 局部变量表：存储基本数据类型和对象引用
- 操作数栈：方法执行的工作区，用于计算方法执行过程中的临时结果
- 动态链接：指向方法在运行时常量池中的符号引用
- 方法返回地址：方法执行完成后返回调用者的地址




特点：
- 线程私有，生命周期与线程相同
- 栈深度超过限制会抛出StackOverflowError
- 栈无法扩展时会抛出OutOfMemoryError


虚拟机栈配置参数：
- **-Xss**：每个线程的栈大小，默认值为1M，通常情况下不需要调整(`-Xss1M`)

### 3.本地方法栈（Native Method Stack）
作用：存储本地方法（Native Method）的调用信息，用于执行本地（Native）方法
特点：
- 线程私有，生命周期与线程相同
- HotSpot虚拟机中将本地方法栈和虚拟机栈合二为一
- 同样会抛出StackOverflowError和OutOfMemoryError异常


### 4.堆（Heap）
作用：存储对象实例和数组，在Java程序运行时几乎所有的对象都在堆中分配。
JVM将Heap划分为 `年轻代（Young Generation）` 和 `老年代（Old Generation）`，在Java 8及之前还可能有 **永久代（PermGen）**。从Java 8开始，永久代被 `元空间（Metaspace）` 替代，移到了堆外。



```txt
Heap（Java8+）

+---------------------------------------------------+
|                     JVM Heap                      |
|  +----------------------+  +--------------------+ |
|  |   Young Generation   |  |   Old Generation   | |
|  | +-----+ +----+ +----+|  |                    | |
|  | |Eden | | S0 | | S1 ||  |                    | |
|  | +-----+ +----+ +----+|  |                    | |
|  +----------------------+  +--------------------+ |
+---------------------------------------------------+

```

分区：
- 新生代（年轻代 Young Generation）：存放新创建的对象。大部分对象声明周期较短，被频繁Minor GC回收。
    - Eden区：新对象分配的内存区域
    - Survivor(From/To，也称为Survivor0和Survivor1)区：
        - S0区
        - S1区
- 老年代（Old Generation）：长期存活的对象
- 永久代（PermGen）：Java8+替代永久代，并移至堆外（Metaspace元空间）

特点：
- 线程共享，生命周期与JVM相同
- 垃圾回收的主要区域
- 物理上可以不连续，逻辑上连续
- 可以抛出OutOfMemoryError异常
- 可以通过-Xms和-Xmx参数设置堆的初始大小和最大大小


配置参数：
| 参数                  | 说明                           |
| ------------------- | ---------------------------- |
| `-Xms`              | 初始堆大小                        |
| `-Xmx`              | 最大堆大小                        |
| `-Xmn`              | 年轻代大小（包括 Eden + S0 + S1）     |
| `-XX:SurvivorRatio` | Eden 和 Survivor 的比例，默认 8：1：1 |
| `-XX:NewRatio`      | 年轻代与老年代的比值                   |



## 5.方法区（Method Area）
>“方法区是规范，永久代/元空间是 HotSpot JVM 的实现方式。”
“在JDK 7及之前，HotSpot使用永久代实现方法区；从JDK 8开始，永久代被移除，改由元空间实现方法区。”

作用：存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

实现：
- 永久代（Permanent Generation）：Java7及之前的实现方式，位于堆内存中。
- 元空间（Metaspace）：Java8及之后的实现方式，使用本地内存（Native Memory）实现

特点：
- 线程共享，生命周期与JVM相同
- 存储类信息、常量、静态变量、即时编译器编译后的代码等
- 可以抛出OutOfMemoryError异常
- 垃圾回收主要针对常量池和类型卸载

配置参数：
- -XX:MetaspaceSize：元空间的初始大小，默认值为物理内存的1/64
- -XX:MaxMetaspaceSize：元空间的最大大小，默认值为物理内存的1/4


`运行时常量池（Runtime Constant Pool）`是方法区（元数据 Metaspace）的一部分，可以抛出OutOfMemoryError异常

注意：
- 从逻辑上: 运行时常量池是方法区的一部分。
- 从物理存储上：在 JDK8及以后，类的元数据结构（包括运行时常量池的一部分）被拆分了，类结构、方法代码等真正的“元数据”放在了元空间（本地内存），不在堆里。**但运行时常量池中最核心、需要频繁访问和GC管理的内容，比如字符串字面量、intern字符串、数值常量，放在了Java堆中**。


运行时常量池是每个类或接口在加载后，存放在内存中的一张常量表，包含编译期生成的各种`字面量`和`符号引用`，并在运行期间支持动态添加内容（如 String.intern()）。
存储内容：
1. 字面量：字符串字面量（如"hello"）、基本类型的常量（如 3.14, 100, true）、final static 编译期常量（比如 static final int A = 10，常量折叠后变字面量）
2. 符号引用：类和接口的全限定名、字段名和类型、方法名和描述符，这些在编译期是符号（字符串），运行时要解析为实际引用（实际的内存地址）。

运行时常量池和 `intern()` 的关系
```java
String s1 = new String("hello");
String s2 = s1.intern();
String s3 = "hello";
System.out.println(s2 == s3); // true
```
1. new String("hello")：创建堆中对象，不进入常量池。
2. s1.intern()：尝试将 "hello" 放入运行时常量池（如果还没进去），返回池中的引用。
3. "hello" 是字面量，自动在编译期进入常量池。
4. 所以 s2 == s3 为 true，指向同一个常量池中的引用。


生命周期
- 每个类或接口都有自己的运行时常量池。
- 类卸载时，池也会被清理。
- 这意味着大量动态生成类（如反射、大量代理类）可能导致内存泄漏或 OutOfMemoryError（常出现在 JDK 6）。

## 直接内存（Direct Memory）
作用：在Java NIO中，通过直接内存（Direct Memory）分配和回收内存，避免了在Java堆和Native堆之间进行数据复制，提高了性能

特点：
- 直接内存不是虚拟机运行时数据区的一部分，不受Java堆大小限制
- 受本机总内存限制
- 可以抛出OutOfMemoryError异常
- 可以通过-XX:MaxDirectMemorySize参数设置直接内存的最大大小

配置参数：
- `-XX:MaxDirectMemorySize`：直接内存的最大大小，默认值为物理内存的1/4


## 垃圾回收
JVM 的 `GC`（Garbage Collection，`垃圾回收`）机制是**自动内存管理的核心，它负责清除不再使用的对象以释放内存。**

为什么需要GC？
- Java程序不断创建对象
- 堆内存空间是有限的
- 不再使用的对象必须清理，避免内存溢出（OutOfMemoryError）

如何确定一个对象需要回收？
在JVM（Java虚拟机）中，判断一个对象是否应该被回收，核心依据是`对象的可达性（reachability）`。

简单来说，就是看对象是否仍然可被程序访问到。

起始点（GC Roots）：JVM会从一组称为“GC Roots”的对象开始进行搜索。
GC Roots 通常包括：
- 虚拟机栈（栈帧中的本地变量表）中的引用对象
- 方法区中的类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI（Native方法）引用的对象

搜索过程：从GC Roots出发，沿着引用链（对象引用指向另一个对象）向下搜索，所有能够被访问到的对象都称为`可达对象`。
如果一个对象没有被GC Roots引用，或者没有任何对象链路可以追溯到它，则说明它是`不可达对象`。

判断一个对象是否应该被回收，JVM主要通过从GC Roots开始做可达性分析，如果对象不可达，就意味着它不再被程序使用，可以被垃圾回收器回收。

引用类型的不同影响可达性判断：
- 强引用（Strong Reference）：只要存在强引用，对象就不会被回收。
- 软引用（Soft Reference）：当内存不足时，软引用对象可能被回收。
- 弱引用（Weak Reference）：只要GC运行，不管内存是否充足，弱引用对象都会被回收。
- 虚引用（Phantom Reference）：虚引用对象和没有引用几乎一样，主要用于跟踪对象被垃圾回收的状态。


GC的主要目标区域是Heap堆内存，主要包括新生代和老年代。

年轻代中`Eden区`与`S0区`和`S1区`的大小比例为`8：1：1`。

为什么需要两个Survivor区？
- 新生代使用复制算法进行垃圾回收。需要同等大小的区域来复制对象，避免内存碎片

具体流程举例：
第一次Minor GC：
- Eden区和S0区的存活对象被复制到S1区
- 清空Eden区和S0区

第二次Minor GC：
- Eden区和S1区的存活对象被复制到S0区
- 清空Eden区和S1区

如果只有一个Survivor区，复制时没有额外的空间放置存活对象，复制算法就无法进行。
两个区可以互相交替使用，保证复制过程中有“目标区”存放存活对象，避免了碎片和对象覆盖问题。



| GC类型                  | 作用范围                     | 触发时机      |
| --------------------- | ------------------------ | --------- |
| **Minor GC**          | 只回收年轻代                   | Eden 区满了  |
| **Major GC / Old GC** | 回收老年代                    | 老年代空间不足   |
| **Full GC**           | 回收年轻代+老年代+方法区（Metaspace） | 显式调用或内存压力 |


### GC回收流程
1. `Minor GC`流程：只回收新生代，触发条件是Eden区满了，大部分生命周期较短的对象被回收。速度快，停顿短，但频繁。
    
    流程：
    1. 新对象分配在Eden区
    2. Eden区满了 -> 触发Minor GC
    3. 存活对象从Eden区和一个Survivor区复制到另一个Survivor区
    4. 复制完成后，清空Eden区和Survivor区
    5. 若对象经过多次Minor GC仍然存活，会被晋升到老年代
    ```
    Eden + Survivor From -> Survivor To 或 Old
    ```
    
2. `Major GC`只回收老年代，触发条件是老年代空间不足，频率低，但影响大。
    
    流程：
    1. 老年代空间不足或者某些策略触发
    2. 遍历老年代中对象，标记未被引用的对象。
    3. 回收这些无用对象。

3. `Full GC`回收整个堆内存，包括新生代、老年代、元空间（Metaspace）。开销最大，影响大。
    
    流程：
    1. 显式调用System.gc()
    2. 老年代空间不足，Minor GC 后晋升失败。
    3. Metaspace空间不足

GC过程中，所有应用线程都会暂停。
不管是 Minor GC、Major GC，某些阶段都会发生 STW（Stop-The-World）。





## 垃圾回收算法
| 算法名称                         | 主要特点                         | 优点                          | 缺点                                 | 典型应用区域               |
| ---------------------------- | ---------------------------- | --------------------------- | ---------------------------------- | -------------------- |
| **标记-清除 (Mark-Sweep)**       | 1. 标记所有存活对象<br>2. 清除未标记对象    | - 实现简单<br>- 不需要额外空间         | - 会产生大量内存碎片<br>- 清除后内存不连续，可能影响分配效率 | 老年代（老区）              |
| **标记-整理 (Mark-Compact)**     | 标记存活对象，然后将存活对象向一端移动，整理成连续空间，清除未标记的对象  | - 避免内存碎片<br>- 便于大对象连续分配     | - 需要移动对象，开销较大                      | 老年代                  |
| **复制算法 (Copying)**           | 将存活对象从一个区域复制到另一块空闲区域，清理整个旧区域 | - 速度快<br>- 不产生碎片<br>- 分配效率高 | - 需要额外的等大小空间<br>- 空间浪费严重           | 年轻代（Eden + Survivor） |



## 垃圾回收器

1. Serial GC 串行收集器 
    - 单线程执行垃圾回收，使用单核或者内存较小的环境。 
2. Parallel GC 并行收集器 
    - 多线程执行垃圾回收，缩短回收时间，使用多核CPU，追求吞吐量的服务器应用。JDK8默认使用的回收器。
3. CMS 并发标记清除收集器
    - 以低停顿为目标，采用并发标记和清理，减少停顿时间。
    - 时间停顿短，但是可能产生内存碎片。
    - 已被逐步淘汰
4. G1 (Garbage First)垃圾回收器
    - 将堆划分为多个独立区域，增量式回收
    - 目标是低延迟和高吞吐量的平衡
    - 支持预测停顿时间，适合大内存应用
    - 是目前主流的收集器之一，JDK9之后默认使用的垃圾回收器
5. ZGC (Z Grabage Collector)垃圾回收器
    - 低延迟收集器，支持大内存（TB级）
    - 大部分工作并发完成，停顿时间控制在毫秒级别
    - 适合堆延迟敏感的大型服务
6. Shenandoah 垃圾回收器
    - 类似ZGC的低延迟垃圾回收器，由Red Hat主导
    - 也支持大堆内存，目标是极低的停顿时间


---

目前主流的JVM垃圾回收器
- G1收集器：自Java 9之后默认收集器（包括JDK11/17），广泛使用，性能稳定，适合大多数服务器应用。
- ZGC：适合对延迟敏感且内存需求很大的应用，开始在Java 11及以后版本中流行。需要手动开启
- Shenandoah：在一些特定Linux环境和OpenJDK中越来越受欢迎。


启用ZGC的示例参数
```
-XX:+UnlockExperimentalVMOptions -XX:+UseZGC
```
如果你想要极低停顿、对延迟敏感的应用，可以考虑使用ZGC，但G1在大多数生产环境中依然是稳定且广泛使用的默认选择。

简单总结

| 收集器        | 优点             | 适用场景       |
| ---------- | -------------- | ---------- |
| Serial     | 简单，低资源环境       | 小型应用，单核机器  |
| Parallel   | 吞吐量高           | 多核服务器，批处理  |
| CMS        | 停顿短，响应快        | 低延迟应用（已过时） |
| G1         | 平衡延迟和吞吐量，默认收集器 | 大多数服务器应用   |
| ZGC        | 超低停顿，支持大内存     | 延迟敏感的大型服务  |
| Shenandoah | 极低停顿，类似ZGC     | 大内存、低延迟需求  |
---



## JVM 性能优化
JVM性能优化的主要方向：
1. 内存管理优化：
    - 堆内存调优
        - 合理设置堆大小（-Xms和-Xmx）
        - 调整新生代和老年代的比例（-XX：NewRatio）
        - 调整新生代大小（-Xmn）
    - 垃圾回收器选择和调优
        - 选择合适的GC算法（如G1、CMS、ZGC、Shenandoah）
        - 调整GC参数（如-XX：ParallelGCThreads、-XX：ConcGcThreads）  
        - 监控并分析GC日志，减少Full GC的频率
    - 元空间调优
        - 调整元空间大小（-XX：MetaspaceSize和-XX：MaxMetaspaceSize）

2. JIT编译优化
    - 调整即时编译器参数
        - 控制方法编译阈值（如-XX：CompileThreshold）
        - 开启/关闭特定优化（内联、逃逸分析等）
    - 避免过早或过晚编译，保持热方法及时编译，提高运行效率

3.  类加载与类元数据优化
    - 减少类加载和卸载频率，避免元空间溢出
    - 避免动态生成过多类，防止元空间或永久代内存耗尽
    - 使用合适的类加载器策略
4. 性能监控
    - 使用监控工具：jstat, jmap, jstack, jvisualvm, Java Flight Recorder 等
    - 通过监控发现热点方法、内存泄漏、频繁GC等问题
    - 根据问题调整配置参数或代码实现
5. 代码层面配合优化
    - 减少对象创建，尤其是大对象和短生命周期对象
    - 使用对象池、缓存等机制降低GC压力
    - 优化数据结构和算法，减少不必要的计算和内存占用
    - 适当使用String.intern()，合理管理字符串常量池


| 优化方向    | 主要手段及工具                        |
| ------- | ------------------------------ |
| 内存管理    | 堆参数调优，GC策略选择，GC日志分析            |
| JIT编译   | 编译阈值调整，开启/关闭优化，热点代码优化          |
| 类加载/元数据 | 控制类加载频率，元空间大小调整                |
| 监控与分析   | `jstat`，`jmap`，`jvisualvm`，JFR |
| 代码优化    | 减少对象创建，缓存使用，算法和数据结构优化          |



# JVM 面试题

## JVM内存区域是怎么划分的？程序计数器、虚拟机栈、本地方法栈、堆、方法区的作用及特点？
  JVM的内存区域主要分为线程私有区域和线程共享区域两大类。线程私有区域是每个线程独立拥有的，生命周期与线程绑定，线程结束时内存自动回收。
  1. 程序计数器：记录当前线程执行的字节码指令地址（即下一条要执行的指令位置）。
  2. 虚拟机栈：存储方法调用的栈帧（Stack Frame），包含局部变量表、操作数栈、动态链接和方法返回地址等信息。
  3. 本地方法栈：与虚拟机栈类似，用于支持native本地方法的调用。

  线程共享区域​由所有线程共享，生命周期与JVM进程一致。
  4. 堆：用于存储对象实例和数组，是JVM管理的最大内存区域。是GC垃圾回收的主要区域。分区为新生代（Eden、S0、S1）和老年代。
  5. 方法区：存储已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
  6. 运行时常量池：存储类文件常量池的运行时表示，包括字面量（如字符串、final常量）和符号引用（如类、方法引用）。逻辑上是方法区的一部分。

## 堆和栈的区别？
从数据结构上来说，
- 栈是一种后进先出（LIFO Last In First Out）的数据结构，
- 数据结构中的「堆」是一种 优先队列，常见的是 二叉堆（binary heap）。Java 标准库中的 `PriorityQueue` 就是基于 **最小堆** 实现的。

在 Java 中，**堆（Heap）和栈（Stack）**是两种不同的内存区域。每当方法调用时，会在栈中压入一个「栈帧」。方法执行结束后，该栈帧被弹出。
1. 栈存储方法调用的信息：局部变量、参数、返回地址等；而堆存储通过new创建的对象实例和数组。
2. 栈的内存大小固定，而堆的大小可以动态调整。
3. 本地方法栈是内存私有的，生命周期与线程绑定，而堆是内存共享的。



## 方法区在Java8前后有什么区别？

`方法区`是 JVM 规范中定义的内存区域，用于存储类的元信息，包括类名、方法、字段、常量池、静态变量、JIT 编译后的代码等。

在 Java 8 之前，方法区的实现是 `永久代`（PermGen，Permanent Generation），它是 JVM 堆内的一部分。内容包括：类元数据、运行时常量池、静态变量等。
**从 Java 8 开始，永久代被彻底移除**，方法区的实现改为 `元空间（Metaspace）`。
Metaspace 是在 `本地内存（Native Memory）` 中分配，而不是 JVM 堆中。类元信息存储在 Metaspace 中，不再受堆内存限制。**静态变量和运行时常量池移入了 堆内存 中。**


总结：Java 8 移除了 PermGen，改为使用本地内存中的 Metaspace 实现方法区，有效解决了永久代 OOM 的问题，提高了 JVM 的稳定性与可扩展性。


## 堆内存分区？为什么堆分为新生代和老年代？
Java 堆（Heap）是 JVM 中最大的一块内存区域，用于存放对象实例和数组。根据 JVM 的内存模型，堆被划分为两个主要区域：新生代（Young Generation）和老年代（Old Generation）。
这是一种代际内存管理模型（Generational GC），**核心思想是：**`对象的生命周期不同，适合用不同策略处理。`
新生代（Young Gen）包含 Eden 区和两个 Survivor 区（S0 和 S1），轮流充当 From 和 To。
新生对象首先被分配在 Eden 区。`Minor GC` 发生频繁，回收短命对象。对象在新生代中经过多次 GC 后，或占用内存过大，会晋升到老年代。
老年代（Old Gen / Tenured Gen）存放长寿命、晋升过的新生代对象。回收发生在 Major GC（或 Full GC）中，频率低但耗时大。

为什么要分为新生代和老年代？ 原因：大多数对象生命周期很短，而少数对象存活很久。

这是「分代收集算法」的核心思想：

**提升 GC 效率:**
- 新生代对象大多「朝生暮死」，采用 复制算法，快速回收。
- 老年代对象活得更久，采用 标记-清除 或 标记-整理 算法，减少对象复制成本。

**减少 GC 停顿时间:**
- 频繁的 Minor GC 只在新生代中进行，老年代不参与，停顿时间短。
- Major GC 触发较少，提高程序吞吐量。


**总结：JVM 将堆划分为新生代和老年代，是为了配合对象生命周期特征，使用不同的垃圾回收策略，从而提升回收效率并减少停顿时间。**



## 新生代为什么划分Eden和Survivor区？为什么有两个Survivor区？
划分Eden和Survivor区的原因：
- ​**​对象生命周期特性（弱代假说）**：大多数对象都是"朝生夕死"的短生命周期对象，Eden区集中存放新创建的对象，Survivor区作为"筛选区"，存放经过垃圾回收后仍然存活的对象。
- **提高垃圾回收效率**：采用复制算法（Copying）进行Minor GC。只扫描Eden和一个Survivor区（而非整个堆），存活对象被复制到另一个Survivor区，回收后原区域完全清空，无内存碎片。

- **减少晋升到老年代的对象数量，减少老年代压力**：如果没有Survivor区，Eden区每次进行Minor GC，存活对象就会被送到老年代，老年代很快会被填满，触发Major GC。Survivor区的存在减少了被送到老年代的对象，降低了Full GC的发生频率。

设置两个Survivor区（通常称为From和To区）的核心原因：
- **解决内存碎片问题**：单Survivor区会导致存活对象在多次GC后产生内存碎片，双区设计通过"空间换时间"，每次Minor GC时，存活对象从Eden+一个Survivor区复制到另一个Survivor区，保证目标Survivor区的对象始终是紧凑排列的。
- **实现高效的复制算法**：初始状态：Eden + S0有对象，S1为空；Minor GC：将Eden和S0的存活对象复制到S1；交换角色：清空Eden和S0，S1变为新的From区。这种交替复制的方式确保了：总有一个Survivor区是空的（作为下次GC的目标区），内存回收后完全无碎片。
- **优化GC性能**：避免了全区域扫描和整理的开销。


## JVM中的类加载机制？

JVM的类加载机制是Java程序运行的基础，它负责将类的字节码文件(.class)加载到内存中，并进行验证、准备、解析和初始化等操作。
JVM不会一次性加载所有类，而是遵循"按需加载"原则，只有在需要使用某个类时，才会进行加载。
类加载过程主要分为五个阶段：
1. 加载（Loading）：通过类的全限定名（包名+类名），将类的字节码文件加载到内存中，并在方法区（Method Area）存储类的元数据。
2. 验证（Verification）：验证字节码文件的正确性，防止恶意代码破坏JVM。
3. 准备（Preparation）：为类的静态变量分配内存，并设置默认初始值。
4. 解析（Resolution）：将常量池中的符号引用转换为直接引用。
5. 初始化（Initialization）：为类的静态变量赋予正确的初始值。执行类的静态代码块（static{}）和静态变量的赋值操作（代码中的赋值）。


## 什么是双亲委派模型？它有什么作用？


双亲委派模型是一种类加载机制，它规定了类的加载过程。
当一个类加载器收到加载请求时，它首先委托给父类加载器去加载。只有当父类加载器无法加载时，子类加载器才会尝试加载。所有加载器都无法加载时抛出ClassNotFoundException。
类加载器的层次结构：
1. 启动类加载器 Bootstrap ClassLoader：由C++实现，加载JAVA_HOME/lib下的核心类库。
2. 扩展类加载器 Extension ClassLoader：加载JAVA_HOME/lib/ext目录下的扩展类
3. 应用程序类加载器 Application ClassLoader：加载用户类路径（ClassPath）上的类
4. 自定义类加载器：用户可继承ClassLoader实现自己的加载器

双亲委派模型的作用：
1. **保证核心类库安全（防止用户伪造java.lang.String等类）**：防止用户自定义的类（如java.lang.String）替换JVM核心类，避免破坏JVM稳定性。
2. **避免重复加载**：如果父类加载器已经加载了某个类，子类加载器就不会再加载，避免同一个类被多次加载到内存中。
3. **保证类的全局唯一性**：由于类是由加载它的类加载器+类全限定名共同决定的，双亲委派模型确保了核心类只会被Bootstrap ClassLoader加载一次，避免不同类加载器加载同一个类导致冲突。

总结：保证核心类库安全、避免重复加载、确保类全局唯一性。


## 分代收集理论及其依据
分代收集（Generational Garbage Collection）是现代JVM垃圾收集的基础思想。它把堆内存划分为几个不同“代”（generation），针对不同代的对象采用不同的垃圾回收策略，从而提升垃圾回收效率。
JVM堆通常划分为：
- 新生代（Young Generation）
- 老年代（Old Generation，或Tenured Generation）
- （还有永久代 PermGen 或元空间 Metaspace，但它们不属于分代回收的重点）

分代收集的核心思想：绝大多数对象都是“朝生暮死”的，只有少部分对象生命周期较长。

分代收集理论的依据：
1. 弱代假说（Weak Generational Hypothesis）：绝大多数对象都是“朝生暮死”的。
2. 强代假说（Strong Generational Hypothesis）：存活时间较长的对象往往占比较小。

分代收集的优点：
1. 回收效率高：针对不同代的对象采用不同的垃圾回收策略，回收效率高。
2. 减少停顿时间：新生代回收采用复制算法，快速回收且无碎片，老年代采用标记-清除或标记-整理，减少碎片。
3. 适应对象生命周期差异：通过对象晋升机制，优化内存管理。

分代收集工作流程：
1. 新创建对象分配在新生代的Eden区。
2. Minor GC时，回收新生代不再使用的对象。
3. 多次存活后，年龄超过阈值的对象晋升到老年代。
4. 老年代空间不足时，触发Major GC或Full GC。


## 对象如何进入老年代？
在JVM的内存管理中，对象通常首先在新生代(Eden区)创建，但最终可能进入老年代。
1. 年龄阈值晋升（默认机制）:对象年龄计数器​​：每个对象有一个年龄计数器，存储在对象头中。对象每在Survivor区存活一次Minor GC，年龄+1。当对象年龄达到阈值（默认15，可通过-XX:MaxTenuringThreshold调整，年龄阈值最大为15（因对象头中年龄计数器占4位，最大1111=15）），就会被晋升到老年代。
2. 大对象直接晋升：超过指定大小的对象（可通过-XX:PretenureSizeThreshold设置）。大对象直接进入老年代，避免在新生代复制。如大数组、长字符串等。



## 说说垃圾回收机制？GC垃圾回收算法有哪些？标记-清除、标记-整理、复制算法的优缺点？有哪些垃圾回收器？
垃圾回收机制的目标是自动管理内存，回收程序中不再使用的对象，防止内存泄漏，避免程序因为内存耗尽而崩溃。
JVM自动执行垃圾回收，开发者无需手动释放对象内存（不像C/C++），这极大降低了内存管理的复杂度。
JVM堆（Heap）是GC的主要管理区域，堆中存放Java对象。
堆通常分为以下几个区域：
1. 新生代（Young Generation）：新创建的对象先进入这里，包括Eden区和两个Survivor区。
    - Eden区：新对象创建在此。
    - Survivor区（S0和S1）：Eden区中存活下来的对象会被复制到这里。
2. 老年代（Old Generation）：在新生代中经历多次GC仍存活的对象会被晋升到这里。
3. 永久代（Permanent Generation）：存放类的元数据，如类信息、方法、字段等，方法区的实现。。

垃圾回收主要针对堆空间，尤其是新生代和老年代。

垃圾回收的主要算法：
1. 标记-清除算法：首先从GC Root开始，标记所有可达对象，然后清除未标记对象。实现简单，但是会产生内存碎片。
2. 标记-整理算法：标记可达对象，然后将存活对象移动到一端，清除边界外的内存。避免内存碎片，但需要移动对象，效率低。
3. 复制算法：把内存分为两块，将存活对象复制到另一块，清理当前空间。不会产生内存锁边，效率高，但是内存使用效率低。


垃圾回收器：
- Serial GC（串行垃圾回收器）：单线程，适用于单核CPU，简单高效。
- Parallel GC（并行垃圾回收器）：多线程，适用于多核CPU，提高吞吐量。JDK 8 默认使用的垃圾回收器。
- CMS（Concurrent Mark Sweep）：并发标记清除，适用于低延迟场景。
- G1（Garbage-First）：分区回收，兼顾吞吐和低延迟，适用于大内存应用，低停顿需求。JDK9之后的默认垃圾回收器。
- ZGC（Z Garbage Collector）：并发、分代收集，极低停顿，适用于大内存应用，超低延迟场景。

## 一次完整的GC流程是什么？（Minor GC、Major GC、 Full GC的区别）
**Minor GC 新生代**
新创建对象主要在新生代的Eden区分配，Minor GC主要针对新生代回收。
1. 当Eden区空间不足时触发Minor GC。
2. 标记：从GC Roots开始，标记所有新生代中存活的对象。
3. 复制存活对象：将Eden和Survivor区中存活对象复制到另一个Survivor区。
4. 清理回收：清空Eden区和Survivor区。
5. 晋升：多次经过Minor GC仍存活的对象达到一定年龄，晋升到老年代。


**Major GC 老年代**
Major GC主要针对老年代回收。当老年代空间不足或者新生代晋升失败时触发Major GC。
1. 标记：从GC Roots开始，标记所有老年代中存活的对象。
2. 整理：将存活对象移动到一端，清理边界外的内存。
3. 清理回收：清空老年代。


**Full GC 新生代和老年代**
Full GC是对整个堆进行回收，包括新生代、老年代以及永久代（PermGen）或元空间（Metaspace）。包含Minor GC + Major GC，停顿时间最长，影响最大。





## JVM调优参数有哪些？-Xms、-Xmx、-Xmn、-XX:SurvivorRatio等参数的作用
- `-Xms`（初始堆大小）：设置JVM启动时堆的初始大小。例如：-Xms512m 表示初始堆为512MB。
- `-Xmx`（最大堆大小）：设置堆可以扩展到的最大内存。例如：-Xmx2g 表示堆最大为2GB。
- `-Xmn`（新生代大小）：设置新生代大小。新生代包括Eden和Survivor区。例如：-Xmn256m 表示新生代为256MB。
-  `-XX:SurvivorRatio`（Survivor区比例）：设置新生代中Eden区与一个Survivor区的大小比例。例如：-XX:SurvivorRatio=8 表示Eden区占新生代的8/10，两个Survivor区各占1/10。
-  `-XX:NewRatio`（新生代与老年代比例）：设置老年代与新生代大小的比例。例如：-XX:NewRatio=2 表示老年代占堆的2/3，新生代占1/3。
- `-XX:MaxTenuringThreshold`：对象晋升到老年代的年龄阈值，默认15。
- `-XX:PretenureSizeThreshold`：大对象直接进入老年代的阈值，默认0。
- `-XX:+PrintGCDetails`：打印GC详细信息。
- `-Xloggc:gc.log`：将GC日志输出到文件。
- -XX:+UseSerialGC：使用串行垃圾回收器。
- -XX:+UseParallelGC：使用并行垃圾回收器。
- -XX:+UseConcMarkSweepGC：使用并发标记清除垃圾回收器。
- -XX:+UseG1GC：启用G1垃圾收集器。
- -XX:+PrintGCTimeStamps：打印GC时间戳。
- -XX:+PrintGCDateStamps：打印GC日期。
- -XX:+PrintHeapAtGC：在GC前后打印堆信息。
- -XX:+HeapDumpOnOutOfMemoryError：当发生OOM时，自动生成堆转储快照。
- -XX:HeapDumpPath：堆转储快照的路径。
- -XX:+UseCompressedOops：使用压缩指针，减少对象指针大小。
- -XX:+UseCompressedClassPointers：使用压缩类指针，减少类指针大小。
- -XX:+UseFastAccessorMethods：使用快速访问器方法，提高对象访问速度。




## 如何解决频繁Full GC问题？（如何减少Full GC的次数？）
1. 增大堆内存和老年代空间
   - 加大 -Xmx（最大堆）和老年代大小，避免老年代空间不足频繁触发Full GC。
   - 适当调整 -XX:NewRatio 或手动调整新生代和老年代比例，保证老年代有足够空间。
2. 优化对象生命周期和内存使用
   - 减少大对象或长生命周期对象的创建，避免老年代快速增长。
   - 优化业务代码，避免内存泄漏（比如静态集合无限增长、线程池不关闭等）。
   - 减少对象的晋升速度，适当调整 -XX:MaxTenuringThreshold（晋升年龄阈值），延缓对象晋升。
3. 调整垃圾收集器和参数
   - 使用低停顿、并发收集的垃圾收集器，如 G1 GC（-XX:+UseG1GC）、CMS GC（-XX:+UseConcMarkSweepGC）等，减少Full GC的频率和停顿。
   - 监控和调整 Survivor区大小（-XX:SurvivorRatio），保证对象在新生代能被充分回收，避免过早晋升到老年代。
4. 分析和解决内存泄漏：使用工具（如VisualVM、MAT）分析堆快照，找出长时间持有引用导致对象无法回收。优化代码，及时释放资源，避免大对象无谓持有。
5. 避免频繁调用 System.gc():System.gc() 会触发Full GC，避免程序中显式或隐式调用，减少人为触发。
6. 监控和分析GC日志：开启GC日志（-XX:+PrintGCDetails -Xloggc:gc.log），分析Full GC触发时机和原因。根据日志调整参数，针对性优化。

## CPU飙升如何排查？
1. 首先定位CPU高的进程：使用`top`命令查看CPU占用率最高的进程，找到占用CPU最高的进程ID（PID）。
2. 定位具体线程：
    - 获取JVM进程的线程信息：`top -Hp <pid>`，确认哪个线程占用CPU高。找出占用CPU最高的线程ID（TID）。
3.  使用 `jstack` 分析Java线程​：使用`jstack -l <pid> > thread_dump.txt` 导出线程栈。将线程ID（TID）转换为16进制 `printf "%x\n" <TID>`。在 thread_dump.txt 中搜索 `nid=0x<HEX_TID>`，找到对应线程的调用栈
4. 常见原因及排查方法​：
    - 死循环/无限递归​：某个线程长期占用CPU，检查线程栈中的代码逻辑，重点关注 `while(true)`、`递归调用`等。
    - 锁竞争（死锁/活锁）​：多个线程处于 `BLOCKED` 或 `WAITING` 状态，使用 jstack 检查线程状态，查找 `java.lang.Thread.State: BLOCKED` 或 `WAITING` 的线程。
    - 高并发请求​：大量线程处于 `RUNNABLE` 状态，检查业务代码是否有高并发任务
    - 频繁GC：%CPU 高，但业务线程无明显异常。检查 GC 日志，分析 Full GC 频率和耗时。
5. 使用性能分析工具
   - Arthas（阿里开源工具）​：动态分析Java进程，无需重启应用。
   - perf（Linux性能分析工具）​：分析进程的CPU、内存、I/O等性能指标。
   - VisualVM（JDK自带）​：图形化的JVM性能分析工具，提供丰富的功能。
   - Flame Graph（火焰图）​​：可视化CPU热点调用栈，快速定位性能瓶颈


关键思路：
1. ​​先定位进程​​（top）
2. ​再定位线程​​（top -H + jstack）
3. 结合日志/代码分析​​（Arthas / perf）
4. 优化问题代码​​（修复死循环、优化锁、调整GC参数等）

## OOM常见的原因及排查方法
OOM常见原因：
- 堆内存不足：
    - 应用创建了大量对象，堆空间不够用。
    - 内存泄漏：对象无法被垃圾回收，导致内存持续增长。
- 方法区（永久代/元空间）溢出：动态生成了大量类或代理类（比如大量动态代理、反射生成类）。
- 直接内存溢出：
    - NIO使用不当：使用不当的NIO，导致直接内存溢出。


排查方法：
1. 定位OOM发生的位置：分析错误日志的第一行：
    - java.lang.OutOfMemoryError: Java heap space：堆内存溢出。
    - java.lang.OutOfMemoryError: Metaspace：元空间溢出。
    - java.lang.OutOfMemoryError: Direct buffer memory：直接内存溢出。
    - java.lang.OutOfMemoryError: unable to create new native thread：线程溢出。

2. 生成和分析内存快照（Heap Dump）:
   在启动参数上加上：
    - `-XX:+HeapDumpOnOutOfMemoryError` 参数开启堆内存快照生成。
    - `-XX:HeapDumpPath=/path/to/dump` 文件路径。
   使用工具（VisualVM）分析Heap Dump，找出内存占用最大的对象。


针对性解决方案：
1. 堆内存优化：参数调优，增大堆内存大小 -Xms 和 -Xmx，调整新生代和老年代比例 -XX:NewRatio、Survivor区占比-XX:SurvivorRatio=8。
2. 元空间控制：设置元空间初始大小 -XX:MetaspaceSize=256M（避免扩容抖动），限制最大空间（防止无限增长）-XX:MaxMetaspaceSize=512M
3. 直接内存管理：显式释放ByteBuffer等直接内存。